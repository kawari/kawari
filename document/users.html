<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="ja">
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=SHIFT_JIS">
 <META http-equiv="Content-Script-Type" content="text/javascript">
 <META http-equiv="Content-Style-Type" content="text/css">
 <LINK rel="stylesheet" type="text/css" href="kawari.css">
 <TITLE>華和梨 ユーザーズマニュアル</TITLE>
</HEAD>
<BODY>

<H1>プログラマブル準AIモジュール "華和梨" ユーザーズマニュアル</H1>

<DIV align="right">
  <P>
    2004/02/01<BR>
    Phase 8.2.0
  </P><P>
    華和梨開発チーム :<BR>
    NAKAUE.T (Meister), 偽Meister (夢乃), さとー, 酔狂, さくらのにえ
  </P>
</DIV>

<H2>Index</H2>

<A href="index.html" class="toindex">← back</A>
<BR>

<BLOCKQUOTE>
 <A href="#preface">1. はじめに</A><BR>
 <A href="#dictionary">2. 辞書ファイル</A><BR>
 　　<A href="#comment">2.1. コメント</A><BR>
 　　<A href="#security">2.2. セキュリティレベル設定</A><BR>
 　　<A href="#crypt">2.3. 暗号化辞書</A><BR>
 <A href="#entrydef">3. エントリ定義</A><BR>
 　　<A href="#string">3.1. 文と文字列</A><BR>
 　　<A href="#quote">3.2. クォート文字列</A><BR>
 　　<A href="#block">3.3. ブロック</A><BR>
 　　<A href="#multiline">3.4. 複数行対応</A><BR>
 <A href="#subst">4. 置換とエントリ呼び出しと実行</A><BR>
 　　<A href="#entrycall">4.1. エントリ呼び出し</A><BR>
 　　<A href="#execute">4.2. 実行</A><BR>
 　　<A href="#recursivesubst">4.3. 置換の入れ子</A><BR>
 <A href="#entrycallvar">5. エントリ呼び出しのバリエーション</A><BR>
 　　<A href="#setexpr">5.1. 集合演算式</A><BR>
 　　<A href="#entryarray">5.2. エントリ配列呼び出し</A><BR>
 　　<A href="#histryref">5.3. 履歴参照(中級)</A><BR>
 　　<A href="#tmpentry">5.4. 一時エントリ(上級)</A><BR>
 <A href="#expression">6. 演算式</A><BR>
 　　<A href="#expr_comp">6.1. 比較演算</A><BR>
 　　<A href="#expr_logic">6.2. 論理演算</A><BR>
 　　<A href="#expr_bits">6.3. ビット演算</A><BR>
 　　<A href="#expr_nums">6.4. 数値と文字列の扱い</A><BR>
 <A href="#kis">7. インラインスクリプト(中級)</A><BR>
  　　<A href="#statement">7.1. 構文コマンドと関数コマンド</A><BR>
  　　<A href="#if">7.2. if</A><BR>
  　　<A href="#function">7.3. 組み込みコマンドとユーザ定義コマンド</A><BR>
 <A href="#shiorisaori">8. SHIORI/SAORIインターフェース</A><BR>
 　　<A href="#callback">8.1. コールバック</A><BR>
 　　<A href="#systementry">8.2. その他のシステムエントリ</A><BR>
 　　<A href="#beshiori">8.3. 栞としての華和梨</A><BR>
 　　<A href="#besaori">8.4. SAORIモジュールとしての華和梨</A><BR>
 　　<A href="#declaresaori">8.5. SAORIモジュールの使用宣言</A><BR>
 　　<A href="#callsaori">8.6 SAORIモジュール呼び出し</A><BR>
 <A href="#extension">9. 応用編</A><BR>
 　　<A href="#event">9.1. イベント反応</A><BR>
 　　<A href="#communicate">9.2. コミュニケート</A><BR>
 　　<A href="#randomtalk">9.3. 自発トーク</A><BR>
</BLOCKQUOTE>

<A name="preface"></A>
<H2>1. はじめに</H2>

<P>
 ユーザーズマニュアルでは、華和梨のほぼ全ての文法と機能を紹介します。
 これと<A href="kis_reference.html">KISリファレンス</A>で、
 一通りの機能が使えるようになります。
</P><P>
 初めて華和梨を使う方は、
 ユーザーズマニュアルより先に<A href="start.html">Getting Started</A>
 を読み、イメージを掴んでください。
</P><P>
 何もないところからゴーストを作るのは大変手間がかかります。
 簡単に華和梨の動作を確認していくためには、
 コンソールUI版アプリケーション『<A href="kosui.html">幸水</A>』
 を使ってください。幸水なしの華和梨修得は、まず考えられません。
</P>

<A name="dictionary"></A>
<H2>2. 辞書ファイル</H2>

<BLOCKQUOTE>
  <P>
    辞書ファイルとは、
    華和梨に対して、文章や語彙や動作パターンを指示するためのファイルです。
    辞書ファイルが、あなたのゴーストを記述する全てです。
  </P>
</BLOCKQUOTE>

<P>
  <STRONG>華和梨が最初に読む辞書ファイルは&quot;kawarirc.kis&quot;です。</STRONG>
</P><P>
  辞書ファイルは、<SPAN id="type">'='</SPAN>で始まる行によって、
  辞書定義ゾーンと、スクリプト記述ゾーンの二つのゾーンに分かれます。
</P><P>
  辞書定義ゾーンは辞書定義を書く領域であり、
  スクリプト記述ゾーンはKISを直接書き、その場で実行する領域です。
</P><P>
  初期状態(辞書ファイルを読み始めた状態)では辞書定義ゾーンで、
  <SPAN id="type">=kis</SPAN>で始まる行から
  <SPAN id="type">=end</SPAN>で始まる行までがスクリプト記述ゾーンです。
</P>

<DIV class="sample">
 # ここは辞書記述ゾーン<BR>
 sentence : \0\s[7]${地名}よ、私は帰ってきた！\1\s[10]……。\e<BR>
 sentence : \0\s[7]${坊や}は死んだ！　何故か！？\e<BR>
 <SPAN id="red">=kis</SPAN><BR>
 # ここはスクリプト記述ゾーン<BR>
 load dict-gundam.txt;<BR>
 logprint ガンダム辞書のろーど。;<BR>
 <SPAN id="red">=end</SPAN><BR>
 # 再び辞書記述ゾーン<BR>
 地名 : サンシャイン60,晴海,幕張,有明<BR>
</DIV>

<P>
  スクリプト記述ゾーンにおける文法は、
  <SPAN id="type">'$(' 〜 ')'</SPAN>
  の間の文法と完全に同一ですので、ここでは省略します。
  <EM>
    スクリプト記述ゾーンで書いたスクリプトは、
    そのスクリプトが読み込まれた瞬間に実行される
  </EM>
  ということだけ注意してください。
</P><P>
  辞書定義ゾーンにおける文法は3章以下で詳しく述べます。
</P>

<A name="comment"></A>
<H3>2.1. コメント</H3>

<P>
  行頭、<EM>空白記号以外の最初の文字</EM>がシャープ<SPAN id="type">'#'</SPAN>
  だった場合、その行全体はコメントと見なされ、無視されます。
</P><P>
  また、<SPAN id="type">':rem'</SPAN>のみの行から
  <SPAN id="type">':endrem'</SPAN>のみの行までの領域全体もコメントと見なされ、
  無視されます。
</P><P>
  両者とも、後述の全ての文法に優先して処理されます。
  複数行に分けた記述の場合、行の先頭の文字に<SPAN id="type">'#'</SPAN>
  が来ないように注意してください。
  その場合はクォート文字列にするなどして逃げることができます。
</P>

<DIV class="sample">
  <SPAN id="red">:rem<BR>
  =======================================================<BR>
  何行もコメントを書くときは<BR>
  こんな風にすることもできますが<BR>
  むしろ、あるエリアを一括してコメントアウトしたいときの方が<BR>
  便利でしょう<BR>
   =======================================================<BR>
  :endrem</SPAN><BR>
  function checker $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if $[$@arg[0]=~"OK"] $(<BR>
  <SPAN id="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# OKの場合</SPAN><BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo オッケー;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) else $(<BR>
  <SPAN id="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 失敗(?)の場合</SPAN><BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo シテオク;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<BR>
  )
</DIV>


<A name="security"></A>
<H3>2.2. セキュリティレベルの指定</H3>

<P>
 「何か。」から送られてくるイベントの中には、
 ローカルマシン(ゴーストの動作しているコンピュータ)以外の場所から
 SSTPなどを通じて送られてくるものがあります。
 このようなイベントを排除するために
 以下の記述によってセキュリティレベルを設定することが出来ます。
</P><P>
 <STRONG>何も書かなかった場合、自動的に安全な設定(high)になる</STRONG>ので、
 普通は記述する必要はありません。
</P><P>
 記述する際には必ず初期化時に読み込まれるファイルに書いて下さい。
 kawarirc.kisに書くのが確実です。
 ゴーストが動作し始めてからはセキュリティレベルを変更することはできません。
</P>

<DL>
  <DT class="tt">securitylevel level ;</DT>
  <DD>
    セキュリティレベルをlevelに設定する。
    levelに書けるのは以下。
    <TABLE border="0" cellpadding="2" cellspacing="0">
      <TR><TD>0 / low</TD><TD> 全てのイベントを許可する。</TD></TR>
      <TR><TD>1 / middle</TD><TD> 外部からやってきたイベントを禁止。</TD></TR>
      <TR><TD>2 / high</TD><TD> 当面は1(middle)と同じ。</TD></TR>
      <TR><TD>3 / ultrahigh</TD><TD>
	明確にローカルマシン発行と記されたイベントのみ許可。
      </TD></TR>
    </TABLE>
  </DD>
</DL>

<DIV class="sample">
# 指定する場合は、kawarirc.kisのできるだけ<BR>
# 先頭に近い部分を強く推奨します。<BR>
=kis<BR>
securitylevel ultrahigh;<BR>
<BR>
=end
</DIV>

<P>
  なお、華和梨の動作中、
  セキュリティレベルは数値表現(0〜3)で
  <SPAN id="type">&quot;System.SecurityLevel&quot;</SPAN>に格納されています。
  書き換えることは出来ません。
</P>

<A name="crypt"></A>
<H3>2.3. 暗号化辞書</H3>

<P>
  ネタをよりばれにくくするために、辞書ファイルに簡単な暗号化を施すことができます。
  暗号化には付属のkawari_encode2.exeを用います。
  使用方法は、DOSプロンプトで以下のように入力します。
</P>

<DIV class="syntax">
  kawari_encode2 辞書ファイル名1 辞書ファイル名2 ...
</DIV>

<P>
  そうすると、キーワードを聞かれるので、適当なキーワードを入れてください。
  暗号化されたファイルが作成されます。
</P>

<DIV class="sample">
C:\home\suikyo\project\kawari\kiu\current&gt; kawari_encode2 dict-sample.txt<BR>
Input Keyword : this is test
</DIV>

<P>
  辞書ファイルのファイル名の拡張子を「.kaw」に変えたファイルが、
  暗号化された辞書ファイルです。
  辞書ファイル中、
 <SPAN id="type">&quot;:crypt&quot;</SPAN>と書かれた行から、
 <SPAN id="type">&quot;:endcrypt&quot;</SPAN>と書かれた行までが暗号化の対象となります。
  それ以外の行は元のまま残されます。
</P>

<DIV class="sample">
  例 dict-sample.txt<BR>
#############################<BR>
# 著作権表示など<BR>
#############################<BR>
<BR>
# ここから暗号化<BR>
 <SPAN id="red">:crypt</SPAN><BR>
# 会話データ<BR>
sentence : \h昨日${npw}を${npp}で偶然見かけたよ。\e<BR>
sentence : \h${npp}良いとこ一度はおいで、はぁーじょいなじょいな。\e<BR>
# 名詞-固有名詞-人名 ( npw )<BR>
npw : 鈴木一郎 , 山本太郎<BR>
# 名詞-固有名詞-地名 ( npp )<BR>
npp : 首相官邸 , ホワイトハウス<BR>
npp : ${npw}の家<BR>
 <SPAN id="red">:endcrypt</SPAN><BR>
# ここまで暗号化<BR>
</DIV>

<P>
このファイルを暗号化すると、次のようなファイルが生成されます。
 (見やすさのために一部行を折り返してあります)
</P>

<DIV class="sample">
  例 dict-sample.kaw<BR>
#############################<BR>
# 著作権表示など<BR>
#############################<BR>
<BR>
# ここから暗号化<BR>
!KAWA0001uJuYMVcg2jveOeM75g==<BR>
!KAWA0001uMvd1szd1tvdmIKY5NA1SCtCnMPWyM/FOkicw9bIyMU6f<BR>
TNMKeo0EToROhc6BTpeOfrk3Q==<BR>
!KAWA0001uMvd1szd1tvdmIKY5NCcw9bIyMUvfzoaOn46CTBSK8A6d<BR>
ToQOho6fTn5OnU6JznjOg46XToaOnA6DjpdOho6cDn65N0=<BR>
!KAWA0001uJuYLgQ2NJU0fS/0LgQ2NJUo1C4EmJCY1sjPmJE=<BR>
!KAWA0001uNbIz5iCmC9RLmAwUiDhmJSYNuouwykGIOE=<BR>
!KAWA0001uJuYLgQ2NJU0fS/0LgQ2NJUq1i4EmJCY1sjIm JE=<BR>
!KAWA0001uNbIyJiCmDZJKTIyFyv4mJSYO8I7Nzv7O9871 jv9O+A=<BR>
!KAWA0001uNbIyJiCmJzD1sjPxTp0MX4=<BR>
# ここまで暗号化
</DIV>

<P>
  生成された暗号化辞書ファイル「dict-*.kaw」を、kawarirc.kisで指定して下さい。
  暗号化ファイルの拡張子は、.kaw以外に変更しても大丈夫です。
</P>

<P>
  暗号化したファイルを元に戻したい場合は、
  kawari_decode2.exeを使います。
</P>

<DIV class="syntax">
  kawari_encode2 辞書ファイル名1 辞書ファイル名2 ...
</DIV>

<P>
  やはりキーワードを聞かれるので、
  暗号化の時に入力したキーワードを入れてください。
</P>

<DIV class="sample">
C:\home\suikyo\project\kawari\kiu\current&gt; kawari_decode2 dict-sample.kaw<BR>
Input Keyword : this is test
</DIV>

<P>
  すると、拡張子が「.txt」の、復号化された辞書ファイルが作成されます。
</P><P>
  <STRONG>
    注意：すでに同名のファイルがあっても上書きされてしまいます！
  </STRONG>
</P>

<A name="entrydef"></A>
<H2>3. エントリ定義</H2>

<P>
 華和梨は、全てのデータを「エントリ」に分類して保持しています。
 辞書定義とは、エントリ定義行を沢山並べたものです。
 エントリ定義は以下の書式('['〜']'は、無くても良い部分)で書いてください。
</P>

<DIV class="syntax">
 エントリ名 [ <SPAN id="type">,</SPAN> エントリ名<SPAN id="type">,</SPAN> エントリ名 ...  ] <SPAN id="type">:</SPAN> 文 <SPAN id="type">,</SPAN> 文 <SPAN id="type">,</SPAN> 文 ... &lt;改行&gt;<BR>
 エントリ名 [ <SPAN id="type">,</SPAN> エントリ名<SPAN id="type">,</SPAN> エントリ名 ... ] <SPAN id="type">(</SPAN> 文 <SPAN id="type">,</SPAN> 文 <SPAN id="type">,</SPAN> 文 ... <SPAN id="type">,</SPAN>&lt;改行&gt;<BR>
 </SPAN> 文 <SPAN id="type">,</SPAN> 文 <SPAN id="type">,</SPAN> 文 ... &lt;改行&gt;<BR>
 ...
 <SPAN id="type">)</SPAN>
 <BR>
</DIV>

<BLOCKQUOTE><I>
  Phase 8では、以前「単語」と呼んでいたものを、
  「文」と「単語」に区別していますが、
  主に細かい文法定義上の問題ですので気にしなくて結構です。
</I></BLOCKQUOTE>

<P>
 コロン<SPAN id="type">":"</SPAN>やカンマ<SPAN id="type">","</SPAN>の
 前後には自由に空白を入れられます。
</P><P>
 エントリを複数並べる形式は、同じ文を複数のエントリに登録する場合に使って下さい。
 <SPAN id="type">'('〜')'</SPAN>で囲う後者の形式は、
 文を何行にも分けて並べたい場合に使ってください。
 <SPAN id="type">'('〜')'</SPAN>の間は自由に改行できます。
 これはその中に幾つもの文を並べられる点で、
 後述の「ブロック」とは異なるので注意してください。
 分かりづらければ使わなくても構いません。
</P>

<DIV class="sample">
 # 単語の登録<BR>
 お昼の挨拶 : こんちは。, ちーっす。, にょース。,やっ, ゴルァ<BR>
 萌え, コスプレ : メイド, 眼鏡っ娘, チャイナ服<BR>
 <BR>
 # 文章の登録も同じです<BR>
 ランダム会話.夜更かし : \0\s[0]やっぱり緑茶でしょ。\1\s[10]…\w8…\w8は？\w8\0\s[3]コーヒーより緑茶の方がカフェインは多いよね。\1\s[10]そやな。\w8\0今夜も仕事は続きそうなので、緑茶を飲もうかと――――\1\s[11]スコッチ\0\s[2]……\w8\w8え？\1\s[11]スコッチ\e<BR>
 <BR>
 # どこいつ的文章の例<BR>
 ランダム会話.電波系 : 私たちは、たぶん、${地名}と${地名}にひきさかれる${人間関係}の、最初の世代だ。<BR>
 <BR>
 # イベント処理スクリプトなど(後述)も同じ<BR>
 イベント.OnCommunicate : $(if $[$(Reference 0)=="まゆら"] ……これは夢？　それともまぼろし？)
</DIV>

<P>
 エントリ名に使える文字は以下です。
 強調してあるものは、新たに使えるようになったものです。
</P>

<DIV class="syntax">
 英数字(<SPAN id="type">A〜Za〜z0〜9</SPAN>) / 
 <EM>アットマーク</EM>(<SPAN id="type">'@'</SPAN>) /
 <EM>クエスチョンマーク</EM>(<SPAN id="type">'?'</SPAN>) /
 ピリオド(<SPAN id="type">'.'</SPAN>) /
 アンダーバー(<SPAN id="type">'_'</SPAN>) /
 いわゆる全角文字
</DIV>

<P>
 ただし、アットマーク<SPAN id="type">「@」</SPAN>
 は<A href="#tmpentry">一時エントリ</A>に用いるので、普段は使わないでください。
 さらに、エントリ名の先頭に<SPAN id="type">「.」</SPAN>は使えません。
 また、エントリ名中に<SPAN id="type">「.」</SPAN>が連続した場合、
 一つにまとめられます(<SPAN id="type">npw.....special</SPAN> → <SPAN id="type">npw.special</SPAN>)。
 <SPAN id="type">'System.'</SPAN>で始まるエントリは、
 華和梨が特別に使うエントリ名ですので勝手に使ってしまわないように注意してください。
</P><P>
 以上の決まり事を守る限り、エントリ名は自由に決められます。
 自分にとって分かりやすい名前にしてください。
 いわゆる「全角文字」が自由に使えるので、積極的に使うと良いでしょう
 (タイプは少し面倒かもしれませんが……)。
</P>


<A name="string"></A>
<H3>3.1. 文と文字列</H3>

<P>
  文は、「文字列」「置換」「ブロック」を好きなだけ並べたものです。
  <A href="#subst">置換</A>と<A href="#block">ブロック</A>は後述します。
</P><P>
  文字列は、例えば以下のようなものです。
</P>

<DIV class="sample">
  \0\s[3]死んだゴーストにしてやれることなんて無いさ。\1\s[10]……心にもないことを\e
</DIV>

<P>
 ほとんどの文章は、このように地の文としてそのまま書くことができます。
 しかし、ごく少数(以前よりも減っています)ながら、使えない文字があります。
</P><P>
 まず、以下の記号は、<STRONG>必ず</STRONG>使えません。
 後述の<A href="#block">ブロック</A>の中では、これ以外の制限はありません。
</P>

<DIV class="syntax">
 クォート2種 <SPAN id="type">'&quot;' , '''</SPAN> /
 ドルマーク <SPAN id="type">'$'</SPAN> /
 丸括弧 <SPAN id="type">'(' , ')'</SPAN></LI>
</DIV>

<P>
 エントリ定義文にベタに書いている場合、
 さらにカンマ<SPAN id="type">','</SPAN>が使えません。
 また、インラインスクリプト中にベタに書いた場合、
 セミコロン<SPAN id="type">';'</SPAN>が使えません。
 それぞれ、その場所で文を区切るために使われるため、使えないことは感覚的に分かります。
 実質的に気を付けなければならないのは最初に挙げたものだけです。
</P><P>
 また、文の前後、及び行の先頭末尾にあるベタの空白文字
 (半角スペース、タブ、改行可能な場所では改行)は無視されます。
 こうした場所に空白を書くには、次のクォートを使ってください。
</P>

<DIV class="sample">
 テスト文字列 : We are the champions ","my friends<BR>
 <BR>
 =kis<BR>
 echo ${テスト文字列}<BR>
 # 「We are the champions ,my friends」が返る<BR>
 =end<BR>
</DIV>

<A name="quote"></A>
<H3>3.2. クォート文字列</H3>

<P>
 前述の使えない文字や文頭文末の空白を文字列として華和梨の文に含めるには、
 クォート文字列を使います。
</P>

<DIV class="sample">
  "&nbsp;&nbsp;&nbsp;&nbsp;クォート文字列の中では空白も
  ${エントリ}呼び出し形式も、カンマ(,)や括弧や、セミコロン(;)も書けます"
</DIV>

<P>
  上のように、
  ダブルクォート<SPAN id="type">(")</SPAN>もしくは、
  (シングル)クォート<SPAN id="type">(')</SPAN>
  で囲まれた文字列を「クォート文字列」と呼びます。
  クォート文字列では、ほぼ全ての文字を、「書いたまま」の形で出力できます。
</P><P>
  クォート文字列では出力できない文字はありません。
  が、記述上、ちょっと変わった書き方をしないといけないことが2つだけあります。
</P>

<DL>
  <DT>「\"」もしくは「\'」 (クォートに使っている文字の方)</DT>
  <DD>
    「"」もしくは「'」が出力されます。
    クォート文字列内で、クォートに使っている文字を出力するために使います。
  </DD>
  <DT>「\\」</DT>
  <DD>
    「\」が出力されます。
    <STRONG>
      「\」マークを出力するために必ず「\\」を書かなければならないわけではない
    </STRONG>
    ことに注意してください。通常は、そのまま"\c"や"\s"などと書いてください。
  </DD>
</DL>

<P>
  さて、では「ダブルクォートを出力する」にはどうすればいいでしょうか。
</P>

<DIV class="sample">
  <SPAN style="color:red">"\""</SPAN>${偽名}<SPAN style="color:red">"\""</SPAN>って呼ぶなーっ！
</DIV>

<P>
  このようにするのが一つの答えです。もう一つは：
</P>

<DIV class="sample">
  <SPAN style="color:red">'"'</SPAN>${偽名}<SPAN style="color:red">'"'</SPAN>って呼ぶなーっ！
</DIV>

<P>
 いずれも、色が変わっている部分がクォート文字列です。
</P><P>
 もう一つ。閉じクォート直前に\マークを出力するには：
</P>

<DIV class="sample">
 echo-mode &gt; 華和梨では、"こんな風に→「\\\"」"書くと、クォート直前に\が書けます。<BR>
 華和梨では、こんな風に→「\"」書くと、クォート直前に\が書けます。<BR>
 <BR>
 echo-mode &gt; 華和梨では、'こんな風に→「\"」'書くと、クォート直前に\が書けます。<BR>
 華和梨では、こんな風に→「\"」書くと、クォート直前に\が書けます。<BR>
</DIV>


<A name="block"></A>
<H3>3.3. ブロック</H3>

<P>
  文中、<SPAN id="type">'(' 〜 ')'</SPAN>で囲まれた部分を
  「ブロック」と呼びます。
  <SPAN id="type">'<EM>$(</EM> ' 〜 ')'</SPAN>は、
  後述のインラインスクリプトですので、間違えないでください。
</P><P>
  ブロックの効果は2つだけです。
</P>

<UL>
  <LI>ブロックの中を強制的に一つの単語要素とみなさせる
    (そのため、<SPAN id="type">','</SPAN>や<SPAN id="type">';'</SPAN>などの、
    文を区切るための文字が単語の一部としてみなされます)</LI>
  <LI>ブロックの中では改行が許される</LI>
</UL>

<P>
  空白文字は通常通り無視されます。
  置換のルールなども全て他の場所と同じです。
  また、ブロック用の括弧<SPAN id="type">'(', ')'</SPAN>は、
  もちろん出力には現れません。
</P><P>
  ブロックは、主に複数行に分けて文を書きたいときに使われます。
</P>

<DIV class="sample">
 # 従来<BR>
 sentence.メインメニュー : \t\0\s[0]メニューだよん\n\n\q0[RandomTalk][トーク]\q1[TestCommand][テスト]\q2[Communicate][コミュニケート]\q3[PrefTalk][トーク設定]\q4[Cancel][キャンセル]<BR>
 <BR>
 # Phase 8<BR>
 sentence.メインメニュー : <SPAN id="red">(</SPAN><BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\t\0\s[0]メニューだよん\n<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\q0[RandomTalk][トーク]<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\q1[TestCommand][テスト]<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\q2[Communicate][コミュニケート]<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\q3[PrefTalk][トーク設定]<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\q4[Cancel][キャンセル]<BR>
 <SPAN id="red">)</SPAN>
</DIV>

<P>
 ブロックを使って複数行記述をしていても、
 エントリ定義の最後には必ず改行が必要なことに注意してください。
</P>
<DIV class="sample">
  呪文 : (修行するぞ修行するぞ<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修行するぞ修行するぞ<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修行するぞ修行するぞ)
</DIV>
<P>
  上記は、こうも書けます。
</P>
<DIV class="sample">
  呪文 : (<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修行するぞ修行するぞ<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修行するぞ修行するぞ<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修行するぞ修行するぞ<BR>
  )
</DIV>
<P>
  しかし、<EM>これは間違いです。</EM>
</P>
<DIV class="sample">
  呪文 : <BR>
  (<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修行するぞ修行するぞ<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修行するぞ修行するぞ<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修行するぞ修行するぞ<BR>
  )
</DIV>
<P>
  なぜなら、<SPAN id="type">「呪文 : 」</SPAN>のところで、
  エントリ定義文が終わってしまっているからです。
</P>

<A name="multiline"></A>
<H3>3.4. 複数行対応</H3>

<P>
 <STRONG>
  「開き括弧に対応する閉じ括弧が来ない間は改行がいくらあってもよい」
 </STRONG>
 というのが、Phase 8の複数行対応の考え方です。
  ブロック、エントリ呼び出し、エントリ配列呼び出しの添え字部、
 演算式、インラインスクリプトなど、
 括弧に囲まれた場所すべてにおいて、
 文法的に空白が許される場所ならばどこにでも改行が入れられるようになりました。
 そうした場所では改行は空白文字(スペースやタブと同じ)と見なされます。
</P><P>
 また、括弧書きのエントリ定義(<SPAN id="type">「エントリ名 '(' ')'」</SPAN>形式)により、
 エントリ定義中に全く自由に複数行記述ができるようになりました。
</P>

<A name="subst"></A>
<H2>4. 置換とエントリ呼び出しと実行</H2>

<BLOCKQUOTE>
 <EM>
  最も重要な章です。
  疑問が湧くたびにここに立ち戻り、繰り返し読んで理解してください。
 </EM>
</BLOCKQUOTE>

<P>
 上記までで、エントリが呼び出されたとき、
 どんな文字列でも出力できるようになりました。
 しかし、華和梨が真に華和梨たる知的動作を行うためには、
 次に述べる置換機能を欠かすことができません。
</P>

<P>
 <EM>華和梨は4つの置換機能を持っています。</EM>
 そのいずれもが、<SPAN id="type">'$'</SPAN>で始まり、
 括弧記号などで決められる特定の範囲を持っています。
</P>

<DIV class="sample">
 # [1] エントリ呼び出し<BR>
 <SPAN id="green">${エントリ名}</SPAN><BR>
 <BR>
 # [2] エントリ配列呼び出し<BR>
 <SPAN id="green">$エントリ名[数字]</SPAN><BR>
 <BR>
 # [3] 演算式<BR>
 <SPAN id="green">$[式 (1+2*3とか)]</SPAN><BR>
 <BR>
 # [4] インラインスクリプト<BR>
 <SPAN id="green">$(スクリプト文; スクリプト文; スクリプト文 ... )</SPAN>
</DIV>

<P>
 これらの詳細については順番に詳しく解説します。
 ただ、いずれの機能についても、
 <STRONG>
  置換部(<SPAN id="type">'$'</SPAN>で始まる記述)を、その実行結果で置き換える
 </STRONG>
 という一点は共通です。
 中には実行結果が無いものもあります。
 そうしたものは、単に置換記述が見えなくなるだけ(空文字列で置き換えた)となります。
</P><P>
 また、置換はその文が実行されるたびに起きます。
 ですから、特にランダムな動作をするエントリ呼び出しなどは、
 文を実行するたびに違った結果を返します。
</P>

<A name="entrycall"></A>
<H3>4.1. エントリ呼び出し</H3>

<P>
 エントリに登録した文を呼び出すことを「エントリ呼び出し」と言います。
 例えば、「人名」という名前のエントリを呼び出すには、以下のように書きます。
</P>

<DIV class="sample">
 # 人名エントリに幾つかの人名を登録<BR>
 人名 : サザエ, カツオ, ワカメ, タラ, フグタ<BR>
 <BR>
 # 人名エントリを呼び出すときは、このように書く<BR>
 ${人名}
</DIV>

<P>
 エントリ呼び出しのすることは2つです。
</P>

<OL>
  <LI>エントリに登録されている文の中から一つをランダムで選ぶ</LI>
  <LI><STRONG>選んだ文を実行する</STRONG></LI>
</OL>

<P>
 2番目の「実行する」ことが重要なので、覚えてください。
 場合によって「評価する」「評価される」などとも呼ばれます。
</P><P>
 次節に続きます。
</P>

<A name="execute"></A>
<H3>4.2. 実行</H3>

<P>
  華和梨辞書でエントリに登録するときの文は、
  決してそのまま「何か。」などに送られる形ではありません。
</P>

<DIV class="sample">
  \0\s[0]私は<SPAN id="red">${なまえ}</SPAN>。<SPAN id="red">${しょくぎょう}</SPAN>やってます。相方は<SPAN id="red">${ともだち}</SPAN>だよ。\e
</DIV>

<P>
  上の例は、${なまえ}、${しょくぎょう}、${ともだち}
  のそれぞれが正しい文字列に置き換わることを意図しています。
</P>

<DIV class="sample">
  # エントリ定義<BR>
  なまえ : さくら<BR>
  しょくぎょう : ゴースト<BR>
  ともだち : うにゅう
</DIV>

<P>
  このような辞書があった場合、先ほどの例を<STRONG>実行</STRONG>すると正しい文字列になるでしょう。
</P>

<DIV class="sample">
  \0\s[0]私は<SPAN id="red">さくら</SPAN>。<SPAN id="red">ゴースト</SPAN>やってます。相方は<SPAN id="red">うにゅう</SPAN>だよ。\e
</DIV>

<P>
  つまり、
</P>
<P>
  <STRONG>「実行」＝「置換を実際に行うこと」</STRONG>
</P>
<P>
  と覚えてください。
  華和梨を使い込んでいくと、
  置換が行われるタイミングを知ることがどうしても必要となります。
  込み入った文を書いて混乱してしまったとき、
  「実行(あるいは評価)」が行われるのがいつなのか、
  それに注意するようにしてください。
</P><P>
  このルールを知れば、クォート文字列の扱いと置換が異なることも理解できると思います。
  クォート文字列における「エスケープ」(<SPAN id="type">\&quot;</SPAN>など)は、
  実行されるたびに結果が変わる必要はありません。
  そこで、読み込まれた段階で既にエスケープの処理は行われています。
</P>
<!--
<P>
  実際、辞書読み込みプロセスを終えて華和梨内部に保持されているデータとしては、
  クォート文字列と地の文の区別はありません。
  一方、置換機能部は、ただの文字列とは別のものとして既に認識されています。
  ですから、クォートを外した結果、
  <SPAN id="type">'${'〜'}'</SPAN>
  などの文字列が現れたとしても、それが置換として機能することはありません。
  これをもう一度「読み直す」ためには、
  <SPAN id="type">eval</SPAN>という特殊なKISコマンドを使う必要があります。
</P>
-->
<BR>

<P>
 さて、それ自体が置換機能であるエントリ呼び出しが、
 選び出した文に対してさらに実行を行うため、
 必然的にエントリ呼び出しは何度も行われることになります。
</P>

<DIV class="sample">
  なまえ : さくら , ふたば<BR>
  しょくぎょう : ゴースト , デスクトップマスコット<BR>
  ともだち : うにゅう , ただきちさん<BR>
  批評 : 私から言わせれば${なまえ}って、${しょくぎょう}やってる場合じゃないと思うの。<BR>
  批評 : 私、${なまえ}は嫌いだけど${ともだち}って好きだな。<BR>
 <BR>
  # 入り口。sentenceというエントリ名は歴史的理由による。<BR>
  sentence : ${批評}
</DIV>

<P>
  ここで、<SPAN id="type">${sentence}</SPAN>を<STRONG>実行</STRONG>します。
</P>

<OL>
  <LI>登録された唯一の文である「<SPAN id="type">${批評}</SPAN>」が選択される。</LI>
  <LI>
    実行する。「批評」を指定したエントリ呼び出しが起きる。
    <OL>
      <LI>
	(例えば)「<SPAN id="type">私から言わせれば${なまえ}って、${しょくぎょう}やってる場合じゃないと思うの。</SPAN>」が選択される。
      </LI>
      <LI>
	これも実行する。まず、「なまえ」のエントリ呼び出し。
	<OL>
	  <LI>「さくら」が選択される。</LI>
	  <LI>実行する。置換子が無いので、変化無し</LI>
	</OL>
	「${なまえ}」が「さくら」と置き換えられる。<BR>
	「しょくぎょう」のエントリ呼び出し。
	<OL>
	  <LI>「デスクトップマスコット」が選択される。</LI>
	  <LI>実行する。置換子が無いので、変化無し</LI>
	</OL>
	「${しょくぎょう}」が「デスクトップマスコット」と置き換えられる。
      </LI>
    </OL>
    「${批評}」が「私から言わせればさくらって、デスクトップマスコットやってる場合じゃないと思うの。」と置き換えられる。
  </LI>
</OL>

<P>
  このように、エントリ呼び出しは、置換子が無くなるまで全ての置換を実行します。
</P>

<A name="recursivesubst"></A>
<H3>4.3. 置換の入れ子</H3>

<P>
 置換は、お互いに入れ子状にすることができます。
 置換の種類は問いません。入れ子の深さにも制限はありません。
</P>

<DIV class="sample">
 $(set あの話題 ${この話題})<BR>
 $[ ${幅} * ${高さ} ]<BR>
 ${ 駄文のリスト.${カウンタ} }<BR>
 $駄文のエントリ[ ${カウンタ} ]<BR>
 今から10年後って言うと、西暦$[ $(date %Y) + 10 ]年だね。<BR>
 <BR>
 # 分かりにくいですが、これでもちゃんと動きます<BR>
 $${間接参照}[$[${ベース}+${ポインタ}]]<BR>
</DIV>

<P>
 入れ子になった置換は<EM>必ず内側から置換されます</EM>。
 例えば：
</P>

<OL>
 <LI><SPAN id="type">今から10年後って言うと、西暦$[ $(date %Y) + 10 ]年だね。</SPAN></LI>
 <LI><SPAN id="type">今から10年後って言うと、西暦$[ 2002 + 10 ]年だね。</SPAN></LI>
 <LI><SPAN id="type">今から10年後って言うと、西暦2012年だね。</SPAN></LI>
</OL>

<P>あるいは</P>

<OL>
 <LI><SPAN id="type">$[ ${幅} * ${高さ} ]</SPAN></LI> 
 <LI><SPAN id="type">$[ 1600 * 1200 ]</SPAN></LI> 
 <LI><SPAN id="type">1920000</SPAN></LI> 
</OL>

<P>
 という具合です。
</P><P>
 Phase 7ユーザは、
 以前はできなかった(entry/evalコマンドで実現していた)
 <SPAN id="type">${ ${ } }</SPAN>
 という入れ子ができるようになっていることに注意してください。
</P>

<DIV class="sample">
 # 「何か。」からのGETリクエストに対し、「event.&lt;イベント名&gt;」を呼ぶ<BR>
 System.Callback.OnGET : ${event.${System.Request.ID}}
</DIV>

<P>
 なお、以下の部分だけは例外的に置換にできません。注意してください。
</P>

<UL>
 <LI>演算式の演算子</LI>
 <LI>構文コマンドのコマンド名 (関数コマンドは可)</LI>
 <LI>集合演算式の演算子</LI>
</UL>

<P>
 例えば以下は<EM>エラー</EM>です。
</P>

<DIV class="sample">
 # 足したり引いたりしたい<BR>
 $[ 100 ${plus_or_minus} 10 ]<BR>
 <BR>
 # 場合によってuntilとwhileを使い分けたい<BR>
 $(${until_or_while} ${条件} $(実行文 ) )<BR>
 <BR>
 # 共通単語を呼びたい<BR>
 ${x${and}y}}
</DIV>


<A name="entrycallvar"></A>
<H2>5. エントリ呼び出しのバリエーション</H2>

<A name="setexpr"></A>
<H3>5.1. 集合演算式</H3>

<P>
  エントリ呼び出しの中身(<SPAN id="type">'${'〜'}'</SPAN>の間)には、
  以下のようなことも書けます。
</P>

<DIV class="sample">
  ${ 作家 & 女性 }<BR>
  ${ ゴースト & 植物 }<BR>
  ${ 男性 + 女性 }<BR>
  ${ ゴースト - 友達 }
</DIV>

<P>
  一行目は「「作家」エントリと「女性」エントリの両方に入っている文の中から一つを選ぶ」
  (もちろん選んだ後に実行します)、
  二行目は「「ゴースト」エントリと「植物」エントリの両方に入っている文の中から一つを選ぶ」、
  同様に、
  三行目は「「男性」エントリと「女性」エントリの<EM>どちらか</EM>」、
  四行目は「「ゴースト」エントリに入っていて「友達」エントリに<EM>入っていない</EM>」
  文から一つを選びます。
</P><P>
  これらは幾らでも並べられます。
</P>

<P>
優先度について：
</P>
<P>
  数式では<SPAN id="type">'*'</SPAN>や<SPAN id="type">'/'</SPAN>が、
  <SPAN id="type">'+'</SPAN>や<SPAN id="type">'-'</SPAN>よりも
  「優先」されます。
  例えば
</P>
<DIV class="sample">
  100 - 10 * 2 = 80
</DIV>
<P>
  など。
</P><P>
  同様に華和梨の集合演算式では<SPAN id="type">'&'</SPAN>が、
  他の2つの演算子よりも「優先」されます。
</P>
<DIV class="sample">
  ${ 男性 + 女性 & 作家 }
</DIV>
<P>
  と書くと、「『男性』、もしくは『女性かつ作家』」が選ばれます。
  これを「男性か女性、かつ作家」に変えるには、数式と同様、こう書きます。
</P>
<DIV class="sample">
  ${ (男性 + 女性) & 作家 }
</DIV>

<P>
 なお、ジャンル分けをやりやすくするために、
 <SPAN id="type">${エントリ名}</SPAN>のみの文は、
 その先のエントリの持つ文まで候補に入れます。
</P>

<DIV class="sample">
 作家 : ${SF作家}, ${ファンタジー作家}, ${ミステリ作家}, ${良くわかんない作家}<BR>
 SF作家 : ティプトリJr.<BR>
 ファンタジー作家 : トールキン<BR>
 ミステリ作家 : クリスティ<BR>
 良くわかんない作家 : キング<BR>
 男性 : アシモフ, トールキン, ポオ, キング<BR>
 <BR>
 =kis<BR>
 echo ${男性 & 作家}<BR>
 # 「トールキン」もしくは「キング」<BR>
 =end
</DIV>

<A name="entryarray"></A>
<H3>5.2. エントリ配列呼び出し</H3>

<P>
  エントリに登録された文の内、ある特定の位置の文を選ぶ時に使います。
</P>

<DIV class="sample">
  # サンプル<BR>
  $sentence[0]<BR>
  $人名[2]<BR>
  $演説[${最後に喋った演説}+1]
</DIV>

<P>
  上記のように「<SPAN id="type">'$' + エントリ名 + '[' + 演算式 + ']'</SPAN>」
  という形式になります。
  演算式については<A href="#expression">後述</A>します。
</P><P>
  エントリ配列呼び出しを実行すると、
  指定エントリの、指定番目(これをインデックスと言います)の文を選択し、実行します。
  インデックスは0から数え始めます。
  普通「一番目」と呼ぶものは、「0」番目ですので気を付けてください。
  また、インデックスに負の値を入れた場合は、後ろから数え始めます。
</P><P>
  指定番目の文が存在しなかった場合の結果は空文字列(<SPAN id="type">""</SPAN>)です。
</P><P>
  以下、<A href="kosui.html">幸水</A>の表記で動作を示します。
</P>

<DIV class="sample">
  # 辞書内容<BR>
  a : 零, 壱, 弐, 参<BR>
  <BR>
  echo-mode &gt; $a[0]<BR>
  零<BR>
  echo-mode &gt; $a[2]<BR>
  弐<BR>
  echo-mode &gt; $a[-1]<BR>
  参
</DIV>

<A name="histref"></A>
<H3>5.3. 履歴参照(中級)</H3>

<P>
  「<SPAN id="type">${数値}</SPAN>」
  という特殊なエントリ呼び出しを履歴参照と呼びます。
  履歴参照は、同じ文脈で行われた置換結果を再度参照するときに使います。
</P>

<DIV class="sample">
  n : 石<BR>
  food : 梨<BR>
  sentence : ${n}のような${food}、${1}のような${0}。
</DIV>

<P>
  上記の例ですと、sentenceの実行結果は「石のような梨、梨のような石。」になります。
</P><P>
  この数値もやはり0から数え始めます。
  また、負の数値を入れると後ろから数え始めます。
</P><P>
  履歴参照は少し特別扱いなので、
  集合演算に使う(<SPAN id="type">${0 & entry}</SPAN>など)ことはできません。
  <SPAN id="type">${ ${エントリ } }</SPAN>のような書き方で、
  内部のエントリ呼び出し結果が数値でも、履歴参照にはなりません。
</P>

<BR>

<P>
  ここからはPhase 7.3.1以前との違いです。
</P><P>
  まず、全ての置換記述が履歴参照によって参照可能になりました。
  つまり、エントリ呼び出し、エントリ配列呼び出し、演算式、インラインスクリプトのことです。
  分かりやすく言えば、「全部の<SPAN id="type">'$'</SPAN>を参照可能」です。
</P><P>
  では、次の場合はどうでしょうか。
</P>

<DIV class="sample">
  n : 石<BR>
  food : 梨<BR>
  sentence : $(echo 「${n}」)のような$(echo 「${food}」)、${1}のような${0}。
</DIV>

<P>
  <SPAN id="type">${1}</SPAN>は、
  <SPAN id="type">$(echo 「${n}」)</SPAN>の中の<SPAN id="type">${n}</SPAN>
  を参照してしまわないのでしょうか？
  もしくは、実行順序としては<SPAN id="type">${n}</SPAN>
  の方が先のように思えますから、
  <SPAN id="type">${n}</SPAN>が0番目で、
  <SPAN id="type">$(echo 「${n}」)</SPAN>が1番目でしょうか。
</P><P>
  答えはどちらでもありません。
  <STRONG>履歴参照においては、<SPAN id="type">'$'</SPAN>の中は関知しません。</STRONG>
  よって、
  <SPAN id="type">$(echo 「${n}」)</SPAN>が0番目で、
  <SPAN id="type">$(echo 「${food}」)</SPAN>が1番目です。
</P><P>
  かと言って、
  <SPAN id="type">'$(' 〜 ')'</SPAN>の中(あるいはエントリ集合演算式などの中)では、
  履歴参照は使えないという意味ではありません。
  もちろん使えます。そして従来通り、括弧の外の以前の置換履歴も参照可能です。
</P>

<DIV class="sample">
  sentence : ${n}のような${food}、$(echo 「${1}」)のような$(echo 「${0}」)。
</DIV>

<P>
  しかし、スクリプトの外から参照するときは、スクリプト全体しか見えません。
</P>

<A name="tmpentry"></A>
<H3>5.4. 一時エントリ(上級)</H3>

<P>
  見かけは全く異なりますが、これは履歴参照とほぼ同じ機能です。
</P>

<P>
  一時エントリとは、華和梨が普段持っている辞書とは別に、
  <STRONG>あるエントリ中の一つの文を実行している間のみ存在する一時的な辞書</STRONG>
  に登録されるエントリです。
  エントリ名の先頭にアットマーク<SPAN id="type">'@'</SPAN>が付くのが特徴です。
</P><P>
  この辞書は、文の実行(置換作業ですね)が始まると同時に、その文専用に一つ作成され、
  終わると同時に削除されます。
</P><P>
  一時エントリは辞書定義時には存在しない(何も実行されていないのですから当然です)ため、
  通常のエントリ定義で文を登録することができません。
  従って、一時エントリは常にスクリプトによって作られることになります。
</P>

<DIV class="sample">
  sentence : $(setstr @名前 ${名前})\0\s[0]名前エントリから${@名前}を選びました。\1\s[10]\w8何で${@名前}\0\s[0]\w2何でって言われても……
</DIV>

<P>
  上記では、文の実行が始まった瞬間に一時辞書(中身無し)が設定され、
  最初のスクリプトで<SPAN clsss="tt">@名前</SPAN>エントリに
  (通常辞書の)名前エントリを呼び出した結果の文字列が入ります。
  それ以降、<SPAN id="type">@名前</SPAN>エントリは、
  この文の実行が終了するまで残ります
  (もちろん、それ以前にスクリプトによって消去することは可能です)。
</P><P>
  履歴参照が、自動的に設定される過去の置換履歴を参照するという単機能であるのに比べ、
  一時エントリは自由に設定・変更・呼び出しができ、
  集合演算にも使えます。
</P>

<DIV class="sample">
  質問 : ${@名前}って何？
</DIV>

<P>
  他のエントリに対して履歴参照できないのと同様、
  他のエントリの一時辞書を参照することはできません。
</P>

<DIV class="sample">
  sentence : $(pushstr @名前 うなぎ)${質問}
</DIV>

<P>
  まず「@名前」一時エントリに、
  「うなぎ」という文字列をセットしてから、
  さきほどの「質問」エントリを呼び出していますが、
  <STRONG>これも無意味です。</STRONG>
  呼び出し元に対して履歴参照できないのと同様、
  呼び出し元の一時辞書を参照することはできません。
</P>

<BR>

<P>
  履歴参照と違う点は、
  同じ文の中でありさえすれば、スクリプトや演算式の中だろうと外だろうと、
  場所に関係なく同じ一時辞書にアクセスできるところです。
  スクリプト中で操作を行った結果をスクリプト外で受け取ることも勿論できます。
  実際、上に挙げた例でも既に行っています。
</P><P>
  一時エントリがもっとも活用されるのは、
  KISのユーザ定義関数においてでしょう。
  以前は「関数的機能を持つエントリ」を呼び出す場合、
  そのエントリに渡すべき値(引数)を特別に用意した(しかし通常辞書の一部である)エントリにセットしてから呼び出すのが通例でした。
  しかし、この形式では問題があります：
</P>
<DL>
  <LI>再入(その関数の実行中に再び同じ関数が呼び出されること)不能</LI>
  <LI>関数型エントリ実行終了時に引数エントリをいちいちクリアしない限り、以前の値が残っている可能性がある</LI>
  <LI>呼び出す際以外に、偶然から引数エントリの値が書き変わる可能性がある</LI>
</DL>
<P>
  Phase 8のユーザ定義関数では、
  華和梨システムによって、引数は自動的に呼び出された関数側の一時エントリ<SPAN id="type">@arg</SPAN>にセットされますので、
  安心して引数を使うことができます。
  複数のユーザ定義関数が互いを何度も呼び合っても、
  その引数のエントリが上書きされたり、過去の引数が残っていたりする危険はありません。
</P><P>
 なお、この機能は無理に使わなくても構いません。
 全てのエントリ名が互いにぶつからないように自分で管理できていて、
 なおかつfunctionによる関数定義を使わない場合は、一時エントリを使う必要はありません。
 エントリ呼び出しを関数代わりに使う従来の手法を踏襲する場合などです。
</P>

<A name="expression"></A>
<H2>6. 演算式</H2>

<P>
 <SPAN id="type">$[ 〜 ]</SPAN>で囲まれた領域を「演算式」と呼びます。
 演算式では、整数演算、ビット単位演算、論理演算、整数比較、文字列比較が行えます。
</P>

<DIV class="syntax">
 <SPAN id="type">$[</SPAN> 演算式 <SPAN id="type">]</SPAN>
</DIV>

<DIV class="sample">
 # 一年は何分？<BR>
 $[ 365 * 24 * 60 ]<BR>
 <BR>
 # 今年は2002年ですか？<BR>
 $[ $(date %y)==2002 ]<BR>
 <BR>
 # あなたの名前は「ほげ」ですか？<BR>
 $[ ${name}=="ほげ" ]<BR>
 <BR>
 # widthからxを引いて、10で割る<BR>
 $[(${width}-${x})/10]
</DIV>

<P>
 使用できる演算子は以下になります。
 結合優先度が高いもの順です。
 優先度の定義は<A href="#setexpr">集合演算の章</A>のものと同じです。
</P>

<TABLE border="0" cellpadding="2" cellspacing="2" style="margin: 2ex 5% 3ex 5%;">
 <TR>
  <TD style="width: 2em;">記号</TD>
  <TD style="width: 2em;">数値</TD>
  <TD style="width: 2em;">文字列</TD>
  <TD style="width: 8em;">動作</TD>
  <TD>例</TD>
 </TR>
 <TR><TD>**</TD><TD>○</TD><TD></TD><TD>累乗</TD><TD class="tt">$[10**2] =&gt; 100</TD></TR>
 <TR class="gb"><TD>-</TD><TD>○</TD><TD></TD><TD>単項マイナス</TD><TD class="tt">$[-10] =&gt; -10</TD></TR>
 <TR class="gb"><TD>+</TD><TD>○</TD><TD></TD><TD>単項プラス</TD><TD class="tt">$[+10] =&gt; 10</TD></TR>
 <TR class="gb"><TD>!</TD><TD>○</TD><TD>○</TD><TD>(単項)NOT</TD><TD class="tt">$[!1] =&gt; false, $[!"hoge"] =&gt; false, $[!""] =&gt; true</TD></TR>
 <TR class="gb"><TD>~</TD><TD>○</TD><TD></TD><TD>(単項)補数</TD><TD class="tt">$[~-10] =&gt; 9</TD></TR>
 <TR><TD>*</TD><TD>○</TD><TD></TD><TD>乗算</TD><TD class="tt">$[10*"2"] =&gt; 20, $["string"*10] =&gt; 0</TD></TR>
 <TR><TD>/</TD><TD>○</TD><TD></TD><TD>除算</TD><TD class="tt">$[10/2] =&gt; 5, $[10/0] =&gt; "" (エラーログ:"devided by 0")</TD></TR>
 <TR><TD>%</TD><TD>○</TD><TD></TD><TD>剰余算</TD><TD class="tt">$[10%3] =&gt; 1</TD></TR>
 <TR class="gb"><TD>+</TD><TD>○</TD><TD></TD><TD>加算</TD><TD class="tt">$[-10+2] =&gt; -8, $[""+1] =&gt; 1</TD></TR>
 <TR class="gb"><TD>-</TD><TD>○</TD><TD></TD><TD>減算</TD><TD class="tt">$[10-3] =&gt; 7</TD></TR>
 <TR><TD>&amp;</TD><TD>○</TD><TD></TD><TD>ビットAND</TD><TD class="tt">$[1&amp;2] =&gt; 0</TD></TR>
 <TR class="gb"><TD>|</TD><TD>○</TD><TD></TD><TD>ビットOR</TD><TD class="tt">$[1|2] =&gt; 3</TD></TR>
 <TR class="gb"><TD>^</TD><TD>○</TD><TD></TD><TD>ビットXOR</TD><TD class="tt">$[1^2] =&gt; 3</TD></TR>
 <TR><TD>&gt;</TD><TD>○</TD><TD></TD><TD>より大きい</TD><TD class="tt">$[10&gt;10] =&gt; false</TD></TR>
 <TR><TD>&gt;=</TD><TD>○</TD><TD></TD><TD>以上</TD><TD class="tt">$[10&gt;=10] =&gt; true</TD></TR>
 <TR><TD>&lt;</TD><TD>○</TD><TD></TD><TD>未満</TD><TD class="tt">$[10&lt;10] =&gt; false</TD></TR>
 <TR><TD>&lt;=</TD><TD>○</TD><TD></TD><TD>以下</TD><TD class="tt">$[10&lt;=10] =&gt; true</TD></TR>
 <TR class="gb"><TD>==</TD><TD>○</TD><TD>○</TD><TD>等しい</TD><TD class="tt">$["string"=="string"] =&gt; true, $[10==8] =&gt; false</TD></TR>
 <TR class="gb"><TD>!=</TD><TD>○</TD><TD>○</TD><TD>等しくない</TD><TD class="tt">$["mac"!="mcdonalds"] =&gt; true</TD></TR>
 <TR class="gb"><TD>=~</TD><TD></TD><TD>○</TD><TD>マッチ</TD><TD class="tt">$["substring"=~"string"] =&gt; true</TD></TR>
 <TR class="gb"><TD>!~</TD><TD></TD><TD>○</TD><TD>非マッチ</TD><TD class="tt">$["substring"!~"string"] =&gt; false</TD></TR>
 <TR><TD>&amp;&amp;</TD><TD>○</TD><TD>○</TD><TD>論理AND</TD><TD class="tt">$["str"&amp;&amp;10] =&gt; "str", $["false"&amp;&amp;10] =&gt; false, $[0&amp;&amp;10] =&gt; false</TD></TR>
 <TR><TD>||</TD><TD>○</TD><TD>○</TD><TD>論理OR</TD><TD class="tt">$["str"||0] =&gt; "str", $["false"||10] =&gt; 10</TD></TR>
</TABLE>

<P>
 幾つかの、四則演算以外の演算について、非常にいい加減な説明をします。
 ここにある演算形式は全て既存の(プログラミング言語としては)一般的な概念ですので、
 正しい説明はその手の教科書をご覧下さい。
</P>

<A name="expr_comp"></A>
<H3>6.1. 比較演算</H3>

<P>
 比較演算(<SPAN id="type">'&gt;', '&gt;=', '&lt;', '&lt;=', '==', '!=', '=~', '!~'</SPAN>)は、
 「その記述が正しいか否か」を確認するものだと思えばよいでしょう。
 結果として、必ず真偽値を返します。
 例えば：
</P>

<DIV class="sample">
 $[ 1 == 10 ]
</DIV>

<P>
 これは明らかに間違っています。
 間違っていることを専門用語で「偽」と言います。
 反対に正しい状態であることは「真」と言います。
 偽の場合は文字列"false"が返ります。
 真の場合は文字列"true"が返ります。
</P>

<DIV class="sample">
 $[ "ばよえ〜ん" == "だいあきゅーと" ]<BR>
 # "false"<BR>
 <BR>
 $[ (100 / 2) &lt; 100 ]<BR>
 # "true"<BR>
</DIV>

<P>
 少し先走りますが、
 この「正しいか間違っているか」を利用して、
 スクリプトで条件分岐することができます。
 華和梨の真偽判断の基準は、論理演算子、および、
 if, while, untilなどの構文コマンド全てにおいて統一されています。
</P>

<DIV class="syntax">
 "", "0", "false"は「偽」、それ以外は全て「真」として扱う
</DIV>

<P>
 では、ディスプレイの幅(screen.widthエントリに格納されているとします)
 が1200を越えていたら「広いディスプレイ」
 エントリを呼ぶようにしてみます。
</P>

<DIV class="sample">
 $(if <SPAN id="green">$[ ${screen.width} &gt; 1200 ]</SPAN> ${広いディスプレイ})
</DIV>

<A name="expr_logic"></A>
<H3>6.2. 論理演算</H3>

<P>
 論理演算(<SPAN id="type">'!', '&amp;&amp;', '||'</SPAN>)は、
 真偽値を使った演算です。
</P>

<P>
 <SPAN id="type">'!'</SPAN>は、「ではない」とでも言えるもので、
 右側の値の逆の値を返します。
 右側の値が真であれば偽、偽であれば真を返します。
</P>

<DIV class="sample">
 $[ ! "ほげ" ]<BR>
 # "ほげ"は、上述の偽の条件に当てはまらないから真。<BR>
 # 従って、その逆である「偽」を返します。<BR>
 # 偽を返す場合は"false"ですから、"false"が返ります。<BR>
 $[ ! 0 ]<BR>
 # 「0」は偽ですから、真が返ります。<BR>
 # "true"になります。
</DIV>

<P>
 <SPAN id="type">'&amp;&amp;'</SPAN>は、「且つ」つまり、
 「〜〜〜 且つ 〜〜〜」です。
 右側の値と左側の値が真の時のみ、真、
 そうでなければ偽を返します。
 必ず、すべての要素を評価します。
 ただし真を返す場合は、"true"ではなく、
 <EM>並列に並べられた'&amp;&amp;'の、一番左側の値をそのまま返します。</EM>
</P>

<DIV class="sample">
 $[ 10 &lt; 100 &amp;&amp; "ほげほげ" == "ほげほげ" ]<BR>
 # 左側、右側の双方が"true"なので、真、つまり"true"を返します。<BR>
 $[ 10 &lt;= ${数値} &amp;&amp; ${数値} &lt;= 100 ]<BR>
 # ${数値}が、10以上100以下の場合、"true"、そうでなければ"false"を返します。<BR>
 $[ ${他のゴースト} && $(暇?) ]<BR>
 # ${他のゴースト}エントリに名前が一つ以上あり、"暇?"コマンドがtrueを返した場合に限り、${他のゴースト}エントリから選ばれたランダムな名前が一つ返ります。
</DIV>

<P>
 <SPAN id="type">'||'</SPAN>は、「または」つまり、
 「〜〜〜 または 〜〜〜」です。
 両側の値のどちらかが真の時、真、そうでなければ偽を返します。
 最初に真の値が出現した時点で評価を終了します。
 ただし真を返す場合は、"true"ではなく、
 <EM>並列に並べられた'||'の左側から順にテストして、
  最初に真となった値をそのまま返します。</EM>
</P>

<DIV class="sample">
 $[ 100 &lt; 10 || "ほげほげ" == "ほげほげ" ]<BR>
 # 後者が正しいので、"true"<BR>
 $[ ${台詞}=~"胸" || ${台詞}=~"尻" ]<BR>
 # ${台詞}が、「胸」か「尻」を含んでいれば"true"<BR>
 $[ ${counter1} || ${counter2} || ${counter3} ]<BR>
 # counter1, counter2, counter3の内、最初に0以外が返ったところでその値を返す。
</DIV>

<A name="expr_bits"></A>
<H3>6.3. ビット演算</H3>

<P>
 ビット演算(<SPAN id="type">'&amp;', '|', '^'</SPAN>)は、
 数値を32bit値として扱う演算です。
 通常はまず使わないでしょう。
</P>

<DIV class="sample">
 $[ 100 &amp; 10 ]<BR>
 # 01100100 &amp; 00001010 -&gt; 00000000 = "0"<BR>
 $[ 64 &amp; 96 ]<BR>
 # 01000000 &amp; 01100000 -&gt; 01000000 = "64"<BR>
 $[ 100 | 10 ]<BR>
 # 01100100 | 00001010 -&gt; 01101110 = "110"<BR>
 $[ 64 | 96 ] <BR>
 # 01000000 | 01100000 -&gt; 01100000 = "96"
</DIV>

<A name="expr_nums"></A>
<H3>6.4. 数値と文字列の扱い</H3>

<P>
 演算式では<EM>数値として扱えるものは必ず数値として扱う</EM>
 という規則があります。
 この結果、次のような事態が起きます。
</P>

<DIV class="sample">
 $[ "001" == "1" ]<BR>
 # "true"になる
</DIV>

<P>
 このような現象を避けたい(必ず文字列として比較したい)場合は、
 KISのcompareコマンドを用いてください。
</P>

<DIV class="sample">
 $[$(compare "001" "1")==0]<BR>
 # "false"になる
</DIV>


<A name="kis"></A>
<H2>7. インラインスクリプト</H2>

<P>
  エントリ呼び出しとは別に、
  <SPAN class="tt">'$(' 〜 ')'</SPAN>でいくつかの文を囲った部分を、
  「インラインスクリプト」と言います。
  また、<SPAN class="tt">=kis</SPAN>のみの行と、
  <SPAN class="tt">=end</SPAN>のみの行で囲った部分も、
  同様に「インラインスクリプト」と言います。
  例えば、日付情報を返すdateコマンドを使うには、次のように書きます。
</P>

<DIV class="sample">
  $(date %H)<BR>
</DIV>

<P>
  インラインスクリプトは、
  エントリ呼び出しの「実行する」機能を、
  より強化したものと考えて下さい。
  エントリ呼び出しと同様、インラインスクリプトを呼ぶと、
  インラインスクリプトは実行結果に置き換わります。
</P>

<DIV class="sample">
  \0\s[0]今日は$(date %n)月$(date %e)日です。\e<BR>
</DIV>

<P>
  エントリ呼び出しと違うのは、
  上の例で言うと「<SPAN class="tt">date</SPAN>」等のコマンド名の後に、
  空白を挟んで「<SPAN class="tt">%n</SPAN>」などの文がある点です。
  コマンド名はエントリ呼び出しのエントリ名に相当し、
  どの機能を呼ぶかを決めます。この機能を「コマンド」と呼びます。
</P><P>
  一方、空白以降の文は、
  コマンドを呼ぶ際に、補助的情報としてコマンドに渡されます。
  この補助的情報を「引数」と言います。
  引数はコマンドの許す限り、空白で区切って幾つでも並べることが出来ます。
</P>

<DIV class="sample">
  $(echo 引数を 幾つも 並べることが出来る 例です)<BR>
  $(matchall ${System.Request.Reference1} 胸 薄い)<BR>
</DIV>



<A name="statement"></A>
<H3>7.1. 構文コマンドと関数コマンド</H3>

<P>
  引数の中に、エントリ呼び出しやインラインスクリプトがあった場合を考えます。
</P>

<DIV class="sample">
  $(set Today $(date %m%d))<BR>
</DIV>

<P>
  コマンドが実行される時、エントリ呼び出しやインラインスクリプトは、
  それぞれの実行結果に置き換わったものが引数となり、コマンドに渡ります。
  上の例では、<SPAN class="tt">$(date %m%d)</SPAN>はその日の日付、
  例えば「0522」に置き換わり、<SPAN class="tt">set</SPAN>コマンドは、
<P>

<DIV class="sample">
  $(set Today 0522)<BR>
</DIV>

<P>
  と書いたのと同じ状態で実行されます。
  引数の中のインラインスクリプトの引数も、
  さらにエントリ呼び出し、インラインスクリプトを含む場合も有り得ます。
  この場合、考え方はエントリ呼び出しと同じです。
  一番内側の括弧から順番に、置換子がなくなるまで置換を実行します。
  そして、その結果が引数としてコマンドに渡ります。
</P>

<DIV class="sample">
  エントリ名 : entry<BR>
  内容1 : 内容2<BR>
  内容2 : あ , い , う , え , お<BR>
  <BR>
  # 模式的な引数の置換の様子<BR>
  $(set ${エントリ名} $(get ${内容1}))<BR>
  →$(set entry $(get 内容2))<BR>
  →$(set entry あいうえお)<BR>
  →entryエントリに「あいうえお」をセットする<BR>
</DIV>

<P>
  しかし、幾つかのコマンドでは、この引数の置換タイミングが違います。
  具体的には、<SPAN class="tt">if、while、foreach</SPAN>など、
  プログラムの流れを司るコマンドと、
  <SPAN class="tt">function、return</SPAN>コマンド等です。
</P><P>
  これらのコマンドは「構文コマンド」又は単に「構文」と呼びます。
  構文コマンドは、<EM>その引数を使うときにエントリ呼び出し等を置換し、
  使わない引数は置換しない</EM>という性質があります。
  具体的な例を挙げます。
</P>

<DIV class="sample">
  $(if $[ ${a} == "Y" ] $(set answer Yes) else $(set answer No))<BR>
</DIV>

<P>
  この例の場合、<SPAN class="tt">$[ ${a} == "Y" ]</SPAN>の結果に応じて、
  <SPAN class="tt">$(set answer Yes)</SPAN>、
  もしくは<SPAN class="tt">$(set answer No)</SPAN>のどちらか一方だけ、
  実行(=置換)されます。
</P><P>
  構文コマンド以外のコマンドは、
  「関数コマンド」又は単に「コマンド」と呼びます。
</P>

<A name="if"></A>
<H3>7.2. if</H3>

<P>
  構文コマンドのうち、<SPAN class="tt">if</SPAN>はPhase 7.3.1と比べ、
  特に文法が変わりました。
  <SPAN class="tt">else</SPAN>と<SPAN class="tt">else if</SPAN>の、
  2つのキーワードを新たに導入しました。
<P>

<P>
  従来の<SPAN class="tt">if</SPAN>は、
  連続した条件分岐で入れ子の<SPAN class="tt">if</SPAN>を使う必要がありました。
  これは括弧の対応を間違いやすいだけではなく、
  間違いを発見しにくいものでした。
  多くの場合、
  入れ子の<SPAN class="tt">if</SPAN>を、
  別のエントリに記述する等の対策が必要でした。
  ただし、こうした入れ子をエントリに分解する方法は、
  条件を追加・削除する際に厄介です。
</P>

<DIV class="sample">
  # 従来のif<BR>
  $(if &lt;条件&gt; &lt;条件が真の時の文&gt; &lt;条件が偽の時の文&gt;)<BR>
  $(if &lt;条件1&gt; &lt;条件1が真の時の文&gt;<BR>
  　　$(if &lt;条件2&gt; &lt;条件1が偽、条件2が真の時の文&gt;<BR>
  　　$(if &lt;条件3&gt; &lt;条件1、2が偽、条件3が真の時の文&gt;<BR>
  　　$(…<BR>
  　　　&lt;すべての条件が偽の時の文&gt; <EM>)…&lt;ifの数に対応した小括弧の連続&gt;…)</EM><BR>
  <BR>
  # あるいは、次のようにエントリに分解する<BR>
  if1 : $(if &lt;条件1&gt; &lt;条件1が真の時の文&gt; ${if2})<BR>
  if2 : $(if &lt;条件2&gt; &lt;条件1が偽、条件2が真の時の文&gt; ${if3})<BR>
  if3 : $(if &lt;条件3&gt; &lt;条件1、2が偽、条件3が真の時の文&gt; ${if4})<BR>
  　…<BR>
  ifn : $(if &lt;条件n&gt; &lt;条件1…n-1が偽、条件nが真の時の文&gt; &lt;すべての条件が偽の時の文&gt;)
</DIV>

<P>
  新しい<SPAN class="tt">if</SPAN>では、こうした問題が起きにくくなっています。
  複数行記述と併せ、一つの処理は一つのエントリの中で完結します。
  メンテナンスが容易になるでしょう。
</P>

<DIV class="sample">
  # 新しいif<BR>
  $(if &lt;条件&gt; &lt;条件が真の時の文&gt; <EM>else</EM> &lt;条件が偽の時の文&gt;)<BR>
  $(if &lt;条件1&gt; &lt;条件1が真の時の文&gt;<BR>
  　　<EM>else if</EM> &lt;条件2&gt; &lt;条件1が偽、条件2が真の時の文&gt;<BR>
  　　<EM>else if</EM> &lt;条件3&gt; &lt;条件1、2が偽、条件3が真の時の文&gt;<BR>
  　　…<BR>
  　　<EM>else</EM> &lt;すべての条件が偽の時の文&gt;)<BR>
</DIV>

<A name="function"></A>
<H3>7.3. 組み込みコマンドとユーザ定義コマンド</H3>
<P>
  エントリと違い、いくつかのコマンドは、ユーザが定義しなくても実行できます。
  このようなコマンドを、「組み込みコマンド」と言います。
  一方、functionコマンドを使いユーザが定義したコマンドを、
  「ユーザ定義コマンド」と言います。
  ユーザ定義コマンドは、一度定義すれば、華和梨が起動している間有効です。
  なお、ユーザ定義コマンドは必ず関数コマンドになります。
</P><P>
  コマンド定義中では、
  <SPAN class="tt">@arg</SPAN>一時エントリを引数として使います。
  第1引数は<SPAN class="tt">$@arg[1]</SPAN>、
  第2引数は<SPAN class="tt">$@arg[2]</SPAN>、
  以降第N引数は<SPAN class="tt">$@arg[N]</SPAN>で参照できます。
  <SPAN class="tt">$@arg[0]</SPAN>は定義中のコマンド名となります。
  以下にコマンド定義の例を示します。
</P>

<DIV class="sample">
  # @argエントリに引数が入っているものとして記述する<BR>
  $(function 改行挿入 $(clear @arg[0] ; foreach i @arg $(echo ${i}\n)))<BR>
  <BR>
  # 使用例<BR>
  # 「カステラ1番\n電話は2番\n3時のおやつは文明堂\n」が返る<BR>
  $(改行挿入 カステラ1番 電話は2番 3時のおやつは文明堂)<BR>
</DIV>

<P>
  次に、既存の組み込みコマンドと同じ名前で、
  ユーザ定義コマンドを定義した場合を考えます。
</P>

<DIV class="sample">
  $(function size $(length $(get $@arg[1])))<BR>
</DIV>

<P>
  この例の場合、<SPAN class="tt">size</SPAN>コマンドは、
  ユーザ定義コマンド版<SPAN class="tt">size</SPAN>に上書きされます。
  必ず組み込みコマンドを呼びたい場合、
  <SPAN class="tt">$(.size entry)</SPAN>のように、
  コマンド名の先頭に「<SPAN class="tt">.</SPAN>」を付けて呼んで下さい。
</P><P>
  また、ユーザ定義コマンドをもう一度定義すると、
  後に定義した方が呼ばれます。
</P>

<DIV class="sample">
  $(function default $(echo さくら) ; default)<BR>
  # 「さくら」が返る<BR>
  <BR>
  $(function default $(echo まゆら) ; default)<BR>
  # 「まゆら」が返る<BR>
  <BR>
  $(function default $(echo 涼璃) ; default)<BR>
  # 「涼璃」が返る<BR>
</DIV>

<P>
  上の例では、<SPAN class="tt">defalut</SPAN>コマンドを3回呼んでいます。
  しかし、毎回直前で定義しなおしているため、3回とも違う結果になります。
</P>

<A name="shiorisaori"></A>
<H2>8. SHIORI/SAORIインターフェース</H2>

<P>
 ここまでに、ゴーストの動作記述方法については、ほぼ全て解説しました。
 が、肝心の
 「ダブルクリックイベントに対応するには？」
 「おすすめURLを表示するには？」
 などの説明を一切しませんでした。
</P><P>
 栞としての機能については、この章でまとめて説明します。
 また、華和梨はSAORIとしても機能しますので、それについても併せて説明します。
</P>

<A name="callback"></A>
<H3>8.1. コールバック</H3>

<P>
 華和梨が情報のやり取りのため、
 特別扱いするエントリを「システムエントリ」と呼びます。
 このうち、幾つかのエントリは呼び出す際の仕組みが、
 他のエントリとまったく違います。
 この節では、このシステムエントリの中でも特異な、
 「コールバックエントリ」を説明します。
</P><P>
 コールバックエントリとは、本体がイベント、NOTIFYを通知してきた際、
 最初に評価するエントリです。
 通常のエントリを評価する場合、エントリ中の文を一つランダムに選び、
 その文の評価結果をエントリの評価結果とします。
 一方、コールバックエントリが本体から呼ばれた場合、
 コールバックエントリ中の<EM>すべての文を添え字順に</EM>評価し、
 <EM>すべての評価結果を結合したもの</EM>を本体に返します。
 仮に、<SPAN class="tt">System.Callback.OnGET</SPAN>エントリが、
 次のような内容だったとします。
</P>

<DIV class="sample">
 System.Callback.OnGET : \0<BR>
 System.Callback.OnGET : \s[0]<BR>
 System.Callback.OnGET : 阿。<BR>
 System.Callback.OnGET : \1<BR>
 System.Callback.OnGET : \s[10]<BR>
 System.Callback.OnGET : 吽。<BR>
 System.Callback.OnGET : \e<BR>
</DIV>

<P>
 もしこのコールバックエントリが本体から呼ばれたとすると、
 本体に返すスクリプトは次のようになります。
</P>

<DIV class="sample">
 \0\s[0]阿。\1\s[10]吽。\e<BR>
</DIV>

<P>
 この結果は、
 KISコマンドの<A href="kis_reference.html#get">get</A>を使い、
 次のように書いた結果と等価です。
 コールバックエントリは、
 <EM>コールバックエントリをgetで評価した結果を本体に返す</EM>と考えて下さい。
</P>

<DIV class="sample">
 get System.Callback.OnGET
</DIV>

<P>
 このコールバックエントリの動作は、
 主にミドルウェアの記述を簡素化する際に有効でしょう。
 ミドルウェアは<SPAN class="tt">OnSecondChange</SPAN>イベント等で、
 多数の独立した機能を動作させることがあります。
 従来、この独立動作する機能を追加したい場合、
 必然的にミドルウェアを書き換える必要がありました。
 しかし、今回からは<SPAN class="tt">System.Callback.*</SPAN>エントリに、
 追加機能を呼ぶ文を追加するだけで大丈夫です。
</P>

<P>
 次に、華和梨の使う全コールバックエントリを示します。
</P>

<DIV align="center">
<TABLE width="80%">
  <TR><TD colspan="2" style="background: #ffe0e0">SHIORI/3.0</TD></TR>
  <TR><TD class="tt">System.Callback.OnGET</TD><TD>GET</TD></TR>
  <TR><TD class="tt">System.Callback.OnNOTIFY</TD><TD>NOTIFY</TD></TR>
  <TR><TD colspan="2" style="background: #ffe0e0">SHIORI/2.x</TD></TR>
  <TR><TD class="tt">System.Callback.OnEvent</TD><TD>SHIORI/2.2 イベント応答、GET Sentenceのみ</TD></TR>
  <TR><TD class="tt">System.Callback.OnGetSentence</TD><TD>SHIORI/2.3b コミュニケート</TD></TR>
  <TR><TD class="tt">System.Callback.OnGetStatus</TD><TD>ステータス取得</TD></TR>
  <TR><TD class="tt">System.Callback.OnResource</TD><TD>SHIORI/2.5リソース取得</TD></TR>

  <TR><TD colspan="2" style="background: #ffe0e0">SAORI/1.0</TD></TR>
  <TR><TD class="tt">System.Callback.OnSaoriExecute</TD><TD>SAORIモジュールとして呼ばれた</TD></TR>
  <TR><TD colspan="2" style="background: #ffe0e0">共通</TD></TR>
  <TR><TD class="tt">System.Callback.OnUnload</TD><TD>切り離しイベント(華和梨が発行)</TD></TR>
  <TR><TD class="tt">System.Callback.OnRequest</TD><TD>その他全てのリクエスト(NOTIFY SHIORI/2.x、TRANSLATE SHIORI/2.x等)</TD></TR>
</TABLE>
</DIV>

<H4>System.Callback.OnRequest</H4>

<P>
 このうち<SPAN class="tt">System.Callback.OnRequest</SPAN>は、
 少し変わっているので解説します。
 このコールバックエントリは、他のコールバックエントリに該当しなかった、
 全ての本体からのコールで呼ばれます。
 具体的にはNOTIFY SHIORI/2.x、TRANSLATE SHIORI/2.6、
 TEACH SHIORI/2.4等が該当します。
 あまり使用しない呼び出しや、将来の本体仕様変更に備えたエントリです。
</P><P>
 どのような呼び出しが来たかを知るためには、
 <SPAN class="tt">System.Request</SPAN>エントリを参照します。
 このエントリに、本体のコール種類を示す文字列である、
 「TEACH」や「NOTIFY OtherGhostName」等が格納されます。
 また、詳しくは次の節で解説しますが、
 本体が渡したヘッダは、
 <SPAN class="tt">System.Request.*</SPAN>エントリ群に格納されます。
 また、本体への応答ヘッダは、
 <SPAN class="tt">System.Response.*</SPAN>エントリ群に書き込みます。
 処理状態を示すステータスコードは、
 <SPAN class="tt">System.Response</SPAN>エントリに書き込みます。
 どのようなヘッダが来るか、どのようなヘッダを返すか、
 どのようなステータスコードを返すかについては、
 本体仕様書を参照して下さい。
</P><P>
 一例として、TEACH SHIORI/2.4を簡易的に処理するスクリプトを示します。
 TEACH SHIORI/2.4は、Wordヘッダに教えた単語が来ます。
 応答の際は、Sentenceヘッダに書きます。
 処理が成功したら、ステータスコードとして200を発行します。
 これをスクリプトにすると、次のようになります。
</P>

<DIV class="sample">
 System.Callback.OnRequest : $(<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;if $[ ${System.Request} == "TEACH" ] $(<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr @Word ${System.Request.Word};<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushstr TeachWord ${@Word};<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response.Sentence \0\s[0]${@Word}ね。\e;<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response 200;<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;);<BR>
 &nbsp;&nbsp;)<BR>
</DIV>

<A name="systementry"></A>
<H3>8.2. その他のシステムエントリ</H3>

<P>
 コールバックエントリ以外にも、幾つかシステムエントリが存在します。
 次に一覧を示します。
</P>

<DIV align="center">
<TABLE width="80%">
  <TR><TD colspan="2" style="background: #ffe0e0">本体からの通知情報</TD></TR>
  <TR><TD class="tt">System.Request.*</TD><TD>リクエストヘッダ</TD></TR>
  <TR><TD colspan="2" style="background: #ffe0e0">本体への応答</TD></TR>
  <TR><TD class="tt">System.Response.*</TD><TD>レスポンスヘッダ</TD></TR>
  <TR><TD class="tt">System.Response.To</TD><TD>SHIORI/2.3b 話しかけたいゴースト名。&quot;stop&quot;で打ち切り。</TD></TR>
  <TR><TD class="tt">System.Response</TD><TD>SHIORI/2.0 ステータスコード</TD></TR>

  <TR><TD colspan="2" style="background: #ffe0e0">その他(リードオンリー)</TD></TR>
  <TR><TD class="tt">System.DataPath</TD><TD>shiori.dllの存在するディレクトリ</TD></TR>
  <TR><TD class="tt">System.SecurityLevel</TD><TD>セキュリティレベル</TD></TR>
</TABLE>
</DIV>

<P>
 特に重要なのは、
 <SPAN class="tt">System.Request.*</SPAN>のリクエストヘッダエントリ群です。
 このエントリ群は、SHIORI/2.x、SHIORI/3.0、SAORI/1.0において、
 本体が送ってきたヘッダに対応します。
 具体例で説明すると、
 例えば「<SPAN class="tt">Reference0: まゆら</SPAN>」というヘッダが来た場合、
 <SPAN class="tt">System.Request.Reference0</SPAN>エントリに、
 「まゆら」という単語をセットすることになります。
</P><P>
 これとは反対に、
 <SPAN class="tt">System.Response.*</SPAN>エントリ群は、
 本体に返すレスポンスヘッダに対応します。
 具体的には、
 例えば<SPAN class="tt">System.Response.Reference0</SPAN>エントリに、
 「さくら」という単語をセットしたと考えます。
 すると本体に返すヘッダに、
 「<SPAN class="tt">Reference0: さくら</SPAN>」というヘッダが追加されます。
 また、<SPAN class="tt">System.Response</SPAN>エントリにセットされた単語は、
 本体に返すステータスコードになります。
</P>

<P>
 リクエストヘッダエントリ、レスポンスヘッダエントリ群は、
 本体から呼ばれてコールバックエントリを評価する直前に、
 一度完全に内容を消します。
</P>

<A name="beshiori"></A>
<H3>8.3. 栞としての華和梨</H3>

<P>
  栞サブシステムの仕事は一見複雑ですが、要約すれば、
  「本体の通知してきたIDから、相応しい応答を割り出して本体に返す」ことです。
  華和梨Phase 8はPhase 7までと比べると、
  こうした栞の仕事を、使用者により「生のまま」見せています。
</P><P>
  代表的な例はイベント応答です。
  華和梨Phase 8はイベント応答、リソース文字列の要求、
  NOTIFY処理の呼び分けを、KISを使って書く必要があります。
  本体が通知してきたID(=イベント名、リソース名)は、
  <SPAN class="tt">System.Request.ID</SPAN>エントリに入っています。
  これを使って呼び分けます。
</P>

<P>
  華和梨Phase 7.3.1と同じ名前でイベントエントリ、
  リソース文字列エントリを使いたい場合、
  <SPAN class="tt">System.Callback.OnGET</SPAN>エントリに次のように書きます。
</P>

<DIV class="sample">
  # GET SHIORI/3.0への応答<BR>
  # イベント、リソース文字列、コミュニケート、etc…<BR>
  # イベントは「event.&lt;イベント名&gt;」、<BR>
  # リソースは「Resourece.&lt;リソース名&gt;」というエントリを呼ぶ<BR>
  System.Callback.OnGET: $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if $[ $(match_at ${System.Request.ID} On) ] <BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${event.${System.Request.ID}}<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;else $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${resource.${System.Request.ID}}<BR>
  &nbsp;&nbsp;)<BR>
</DIV>

<P>
  この例では、例えばマウスのダブルクリックイベントが来た時、
  <SPAN class="tt">event.OnMouseDoubleClick</SPAN>エントリを呼びます。
  また、例えばさくら側の「おすすめURL」の要求があった場合、
  <SPAN class="tt">${resource.sakura.recommendsites}</SPAN>の評価結果を返します。
</P>

<P>
  しかし、SHIORI/3.0ではイベントとリソース文字列要求は、
  本体からの通知形式に差がありません。
  そこで、エントリ名を従来から変更する代わりに、
  記述を簡素化することが出来ます。
  この場合、次のように書きます。
</P>

<DIV class="sample">
  # GET SHIORI/3.0への応答<BR>
  # イベント、リソース文字列、コミュニケート、etc…<BR>
  # 「reply.&lt;要求されている処理名&gt;」というエントリを呼ぶ<BR>
  System.Callback.OnGET : ${reply.${System.Request.ID}}<BR>
</DIV>

<P>
  この例では、例えばマウスのダブルクリックイベントが来た時、
  <SPAN class="tt">reply.OnMouseDoubleClick</SPAN>エントリを呼びます。
  また、例えばさくら側の「おすすめURL」の要求があった場合、
  <SPAN class="tt">${reply.sakura.recommendsites}</SPAN>の評価結果を返します。
</P>

<P>
  最後に、NOTIFYの処理の呼び分け触れます。
  NOTIFYの形式はイベント・リソース文字列要求のGETの場合と、
  ほとんど差がありません。
</P>

<DIV class="sample">
  # NOTIFY SHIORI/3.0の処理<BR>
  # HWnd通知、他のゴースト通知、インストール済みゴースト通知、etc…<BR>
  # 「notify.&lt;通知された情報名&gt;」というエントリを呼ぶ<BR>
  System.Callback.OnNOTIFY : ${notify.${System.Request.ID}}<BR>
</DIV>

<P>
  例えば他に起動中のゴーストの名前がNOTIFYされた場合、
  <SPAN class="tt">notify.otherghostname<SPAN>エントリを呼びます。
</P>

<P>
  ミドルウェアを使わずに華和梨を使う場合、こうした記述が必ず必要です。
  しかし、多くのミドルウェアでは、
  こうした低レベル(よりプログラムに密着した)の記述が、
  既にパッケージ化されています。
  何らかの事情が無い限り、こうしたミドルウェアの使用をおすすめします。
</P>

<A name="besaori">
<H3>8.4. SAORIモジュールとしての華和梨</H3>

<P>
  華和梨はSHIORI規格の準AIモジュールですが、
  同時にSAORI規格モジュールでもあります。
  SAORIモジュールとして使うと、
</P>
<UL>
  <LI>華和梨Phase 7から移行する際、新旧スクリプトを同時に使える</LI>
  <LI>他の栞を使用している場合でも、華和梨の欲しい機能だけを使える</LI>
</UL>
<P>
  といったメリットがあります。
</P>

<P>
  華和梨をSAORIとして使うとき、次の3つのことに注意します。
</P>

<H4>引数の受け取り</H4>

<P>
  華和梨がSAORIとして呼ばれた時、
  <SPAN class="tt">System.Callback.OnSaoriExecute</SPAN>エントリを評価します。
  他のコールバックエントリと同様、所属する全ての単語を評価します。
  この時、SAORIモジュールに与えられた引数は、
  <SPAN class="tt">System.Request.*</SPAN>以下、
  <SPAN class="tt">System.Request.Argument0</SPAN>、
  <SPAN class="tt">System.Request.Argument1</SPAN>
  等のエントリに存在します。
</P><P>
  引数が何個あるか等を知りたい場合、listtreeコマンドを使い、
</P>

<DIV class="sample">
  listtree arguments System.Request
</DIV>
<P>
  として、argumentsエントリを調べると知ることが出来ます。
</P>

<H4>戻り値の引渡し</H4>

<P>
  戻り値を返したい時はコミュニケートと同様、
  <SPAN class="tt">System.Response.*</SPAN>エントリ群を使います。
  SAORI規格に従って、戻り値は、
  <SPAN class="tt">System.Response.Result</SPAN>に書き込みます。
  以下、
  <SPAN class="tt">System.Response.Value0</SPAN>、
  <SPAN class="tt">System.Response.Value1</SPAN>、
  <SPAN class="tt">System.Response.Value2</SPAN>
  等のエントリに補助情報を書き込みます。
</P>

<H4>ステータス</H4>

<P>
  戻り値を返すには、実はこれだけでは不十分です。
  <SPAN class="tt">System.Resopose</SPAN>エントリに、
  ステータスを書き込む必要があります。
  このステータスコードを見て、
  SAORIモジュールを呼び出した側は処理の成功/失敗を判断する為、
  必須情報です。
  主なステータスコードは次の通りです。
<P>

<TABLE border="0" cellpadding="2" cellspacing="2" style="margin: 2ex 5% 3ex 5%;">
<TR><TD>200</TD><TD>引数を正しく理解し、戻り値を書き込んだ</TD></TR>
<TR><TD>204</TD><TD>引数は正しく理解したが、戻り値がない</TD></TR>
<TR><TD>400(省略時デフォルト)</TD><TD>理解できない引数が来た</TD><TR>
</TABLE>

<P>
  なお、
  <SPAN class="tt">System.Callback.OnSaoriExecute</SPAN>の評価結果は、
  ステータスと無関係です。
  この点が他のコールバックエントリと違いますので、注意が必要です
</P>

<DIV class="sample">
  System.Callback.OnSaoriExecute : $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if $[ ${System.Request.Argument0} == "処理1" ] $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SAORI処理1;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;) else if $[ ${System.Request.Argument0} == "処理2" ] $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SAORI処理2;<BR>
  &nbsp;&nbsp;);<BR>
  <BR>
  # SAORI処理をわざわざ関数にする必然性はないのだが…<BR>
  # 新機軸に見慣れて貰うために、あえて関数で記述した。<BR>
  # 普通にエントリとして書いても何の問題もない。<BR>
  # 引数はSystem.Request.*に存在し、関数の引数として与える必要がないから。<BR>
  <BR>
  =kis<BR>
  function SAORI処理1 $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if $[ ${System.Request.Argument1} == "貢物" ] $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Resultのみ返す例<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response.Result "うむ、よろしい！";<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response 200;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;) else $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ResultとValue*を併用する例<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response.Result "貢物はどうした！";<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response.Value0 "文句";<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response.Value1 "不満";<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response.Value2 $(date %y%m%d);<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response 200;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;);<BR>
  );<BR>
  <BR>
  function SAORI処理2 $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if $[ ${System.Request.Argument1} == "1" ] $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Resultなしだが正常終了の例<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response 204;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;) else $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 異常終了の例<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr System.Response 400;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;);<BR>
  );<BR>
  =end<BR>
</DIV>

<A name="declaresaori"></A>
<H3>8.5. SAORIモジュールの使用宣言</H3>

<P>
  SAORIモジュールを使用する際は、
  「これからこのSAORIを使う」という使用宣言の記述が必要です。
  この記述を受けて、
  華和梨はSAORIモジュールを読み込んだり、読み込む準備をします。
</P><P>
  華和梨Phase 8以前では、
  このSAORI使用宣言は<SPAN class="tt">kawari.ini</SPAN>に記述しました。
  しかし、Phase 8から<SPAN class="tt">kawari.ini</SPAN>は廃止になり、
  使用宣言はKISで記述することになりました。
</P>

<P>
  SAORIモジュール使用宣言は、
  <SPAN class="tt">saoriregist</SPAN>コマンドを使います。
</P>

<DIV class="sample">
  saoriregist ＜SAORIモジュール名＞ ＜エイリアス＞ [＜オプション＞]<BR>
</DIV>

<DL>
  <DT>SAORIモジュール名(必須)</DT>
  <DD>SAORIモジュールのファイル名を記述します。拡張子(「.dll」等)を含めます。
  華和梨の存在するフォルダからの相対パスで記述します。</DD>
  <DT>エイリアス(必須)</DT>
  <DD>実際にSAORIモジュールを使用する際、
  使用するモジュールを区別するためのラベルです。
  複数のSAORIモジュールを使う場合、モジュールごとに別の名前を付けてください。
  また、モジュールを一つだけ使う場合も、必ずエイリアスが必要です。</DD>
  <DT>オプション(省略可能)</DT>
  <DD>SAORIモジュールを読み込むタイミングを指定します。
  「<SPAN class="tt">preload</SPAN>」で直ちにに読み込み、
  「<SPAN class="tt">loadoncall</SPAN>」でモジュールを使用する直前に読み込み、
  「<SPAN class="tt">noresident</SPAN>」でモジュールを使用する直前に読み込み、
  使用後に切り離しです。<BR>
  省略した場合、「<SPAN class="tt">loadoncall</SPAN>」と等価です。
  使用するSAORIモジュールのマニュアルに注意書きがない場合、
  通常はオプションを省略して構いません。</DD>
</DL>

<P>
  こうして使用宣言をすると、華和梨からSAORIモジュールを呼び出すことが出来ます。
</P>

<A name="callsaori"></A>
<H3>8.6. SAORIモジュール呼び出し</H3>

<P>
  SAORIモジュールを呼び出す時は、
  <SPAN class="tt">callsaori</SPAN>コマンド、
  <SPAN class="tt">callsaorix</SPAN>コマンドを使います。
  <SPAN class="tt">callsaori</SPAN>コマンド、
  <SPAN class="tt">callsaorix</SPAN>コマンドは、
  先に定義した「エイリアス」でSAORIモジュールを呼びます。
  仮に、<SPAN class="tt">music.dll</SPAN>というSAORIモジュールを、
  「音楽」というエイリアスで使用宣言したとします。
</P>

<DIV class="sample">
  saoriregist music.dll 音楽<BR>
</DIV>

<P>
  このSAORIモジュールの機能が指定した音楽ファイルの再生だとしたら、
  再生する音楽ファイル名を指定するのが普通でしょう。
  この場合、SAORIモジュールに再生するファイル名を伝える必要があります。
  話の都合上、<SPAN class="tt">music.dll</SPAN>は
</P>
<UL>
<LI>第1引数が「play」で再生開始、「stop」で再生停止</LI>
<LI>第2引数が再生開始時は再生するファイル名、停止時は無し</LI>
</UL>
<P>
  という仕様だとします。
</P><P>
  この<SPAN class="tt">music.dll</SPAN>で、
 「<SPAN class="tt">technopolis.mid</SPAN>」という音楽ファイルを再生したい場合、
</P>

<DIV class="sample">
  callsaori 音楽 play technopolis.mid<BR>
</DIV>

<P>
  と書きます。
  <SPAN class="tt">callsaori</SPAN>コマンドのエイリアスより後ろの引数は、
  SAORIモジュールに引数として渡します。
</P>

<P>
  <SPAN class="tt">callsaorix</SPAN>コマンドは、
  SAORIモジュールが戻り値以外に、
  様々な情報を送ってくるタイプの場合に使用します。
  仮に、先ほどの<SPAN class="tt">music.dll</SPAN>が「play」を指示した場合、
  次のような情報を送ってくるとします。
</P>
<UL>
<LI>Result: 再生に成功したら「OK」</LI>
<LI>Value0: 音楽ファイルのタイトル</LI>
<LI>Value1: 音楽ファイルのアーティスト</LI>
<LI>Value2: 音楽ファイルの演奏時間(mm:ss形式)</LI>
</UL>

<P>
  では、<SPAN class="tt">callsaorix</SPAN>を使って、
  音楽ファイル「<SPAN class="tt">Truth21c.mid</SPAN>」を再生します。
  エイリアスは<SPAN class="tt">callsaori</SPAN>コマンド、
  <SPAN class="tt">callsaorix</SPAN>コマンドに共通で使えます。
</P>

<DIV class="sample">
  callsaorix 音楽 music.info play Truth21c.mid<BR>
</DIV>

<P>
  ここで、エイリアスのすぐ後ろの「<SPAN class="tt">music.info</SPAN>」は、
  SAORIモジュールが送ってきた情報を記録する際の、
  基準となるエントリの名前です。このエントリの名前は自由に決められます。
  上の例の場合、次のようなエントリに情報を書き込みます。
</P>
<UL>
<LI>music.info.Value0: "TRUTH(21C Remix)"</LI>
<LI>music.info.Value1: "T-SQUARE plus"</LI>
<LI>music.info.Value2: "05:30"</LI>
<LI>music.info.size: "3"</LI>
<LI>music.info: "SAORI/1.0 200 OK"</LI>
</UL>

<P>
  sizeはValueが何個あるかを示します。
</P>

<P>
  <SPAN class="tt">callsaori</SPAN>、
  <SPAN class="tt">callsaorix</SPAN>はともに戻り値を返す関数コマンドです。
  戻り値はSAORIモジュールの返した<SPAN class="tt">Result</SPAN>ヘッダです。
</P>

<A name="extension"></A>
<H2>9. 応用編</H2>

<P>
  上記を踏まえ、ゴーストの基本動作を実装する際、
  華和梨Phase 8ではどのように記述するのか、
  幾つか例を交えて紹介します。
</P>

<A name="event"></A>
<H3>9.1. イベント</H3>

<P>
  イベント通知の際、本体からのReferenceヘッダを華和梨から参照するには、
  <SPAN class="tt">${System.Request.Reference0}</SPAN>など、
  非常に長いエントリ名を記述する必要があります。
  使ってみると、これは不便です。
  そこで、コマンドを作って記述を簡単にする場合を考えます。
</P><P>
  コマンドを定義する際の注意ですが、
  スクリプト記述ゾーンで定義して下さい。
  辞書記述ゾーンのエントリ定義中でコマンドを定義した場合、
  コマンドの定義は「そのエントリが呼び出されて」初めて機能します。
  多く場合、コマンドは未定義も同然となります。
</P><P>
  では、実際に定義してみます。
</P>

<DIV class="sample">
  =kis<BR>
  # Referenceを返すコマンド "Reference"<BR>
  function Reference $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;# 引数がなかった場合、何も返さない<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if $[ $(size @arg) &lt;= 1 ] $(return);<BR>
  <BR>
  &nbsp;&nbsp;&nbsp;&nbsp;# System.Request.Reference?エントリの一つ目の単語を得る<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;get System.Request.Reference$@arg[1][0];<BR>
  );<BR>
  =end<BR>
</DIV>

<P>
  この例では、同じReference番号のReferenceヘッダが複数来る場合を想定し、
  getで0番目のRefernce?を参照しています。
</P>

<A name="communicate"></A>
<H3>9.2. コミュニケート</H3>

<P>
  他のゴーストに話し掛ける時は、
  <SPAN class="tt">Reference0</SPAN>に話し掛けたいゴースト名をセットして、
  トークを返します。
  <SPAN class="tt">ReferenceN</SPAN>(Nは0以上の整数)を返すには、
  <SPAN class="tt">System.Response.ReferenceN</SPAN>エントリに単語をセットします。
  なお、<SPAN class="tt">System.Response</SPAN>で始まるエントリは、
  コールバックごとに毎回内容が消去されます。
</P>

<DIV class="sample">
  sentence : (<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;$(setstr System.Response.Reference0 毒子)<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;\0\s[0]おーい、毒子さん、聞こえるかーい。<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;\1\s[11]やめとけ、アレは偽毒子だ。変な注射されるぞ。\e<BR>
  &nbsp;&nbsp;)<BR>
</DIV>

<P>
  こうして話し掛けられたゴーストには、
  <SPAN class="tt">OnCommunicate</SPAN>がやってきます。
  SHIORI/3.0から、コミュニケートはイベントの一種になりました。
</P>

<DIV class="sample">
  # 「会話」エントリの全内容を評価し、戻り値の一つをエントリ名として<BR>
  # エントリ呼び出し<BR>
  # 戻り値がなければ、communicate.unknownエントリを呼ぶ<BR>
  reply.OnCommunicate : $(communicate 会話 ${communicate.unknown})<BR>
</DIV>

<P>
  自分から話し掛けるときと同様、
  話し掛けるゴースト名を<SPAN class="tt">Reference0</SPAN>に設定して下さい。
</P><P>
  なお、コミュニケート用コマンドは、
  ユーザ定義コマンドで使いやすいようラッピングするのが得策ですが、
  ここでは一番素直に書いた場合を例示します。
</P><P>
  コミュニケートの基本的書き方は、次のようになります。
</P>

<OL>
<LI>反応するキーワードを書いたエントリを作る。
キーワード群1個につきエントリ一個とする。仮にkeyとする。</LI>
<LI>キーワード群に対応する、返事を書いたエントリを作る。
これもキーワード群1個につきエントリ1個とする。仮にanswerとする。</LI>
<LI><SPAN class="tt">communicate</SPAN>コマンドで束ねるエントリを、
仮に<SPAN class="tt">com</SPAN>とする。</LI>
<LI>キーワード、返事を<SPAN class="tt">com</SPAN>エントリに登録する時は、
  <DIV class="sample">
    com : $(<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;if $(xargs key matchall ${System.Request.Reference1}) <BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;answer<BR>
    &nbsp;&nbsp;)<BR>
  </DIV>
と書く。</LI>
<LI><SPAN class="tt">OnCommunicate</SPAN>イベントで、
  <DIV class="sample">
    $(communicate com)<BR>
  </DIV>
と書く。</LI>
</OL>

<P>
  以上をまとめた例を挙げます。
</P>

<DIV class="sample">
  # 例えば「あなたの名前は何？」に反応する<BR>
  com.key.1 : あなた , 名前 , 何？<BR>
  com.answer.1 : (<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;\0\s[0]私の名前は${myname}です。\s[5]あなたは？\e<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;$(setstr System.Response.Reference0 $(Reference 0))<BR>
  &nbsp;&nbsp;)<BR>
  com.answer.1 : \0\s[4]うー。\1\s[10]すまん、こいつ今機嫌が悪くてな\e<BR>
  com.answer.1 : \0\s[8]…。\1\s[10]無視かよ。\e<BR>
  com : $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if $(xargs com.key.1 matchall $(Reference 1))<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;com.answer.1<BR>
  &nbsp;&nbsp;)<BR>
  <BR>
  # 「胸が無い」と言われるとキれる<BR>
  com.key.2 : 胸 , 無い<BR>
  com.answer.2 : \0\s[25]…。\1\s[11]俺が時間を稼ぐ、早く逃げろ！\e<BR>
  com : $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if $(xargs com.key.2 matchall $(Reference 1))<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;com.answer.2<BR>
  &nbsp;&nbsp;)<BR>
  <BR>
  # 複数のゴーストの呼びかけに応じる例<BR>
  # 「うにゅぼんで一緒に遊ぼう」等に反応する<BR>
  com.key.3 : うにゅぼん , 一緒 , 遊ぼう<BR>
  com.answer.3 : (<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;\0\s[5]うん！じゃ、私は「${installedghost}」使うよ。\e<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;$(setstr System.Response.Reference0 $(Reference 0))<BR>
  &nbsp;&nbsp;)<BR>
  # 反応するゴースト名一覧<BR>
  com.ghost.3  : 黒姉 , まゆら , さくら , せりこ<BR>
  com.ghost.3  : 毒子 , あると , 奈留 , 安子<BR>
  # findを使い、反応するべきゴーストかどうか判定<BR>
  com : $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if $[ $(find com.ghost.3 $(Reference 0)) &gt;= 0 &&<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(xargs com.key.3 matchall $(Reference 1)) ]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;com.answer.3<BR>
  &nbsp;&nbsp;)<BR>
  <BR>
  # あるゴーストに自分の名前を呼ばれたときに反応<BR>
  com.key.4 : ${myname}<BR>
  com.answer.4 : \0\s[5]……$(Reference 0)様！\e$(setstr FlagMode happy)<BR>
  com.ghost.4 : まゆら<BR>
  com : $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if $[ $(Reference 0) == ${com.ghost.4} &&<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(xargs com.key.4 matchall $(Reference 1)) ]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;com.answer.4<BR>
  &nbsp;&nbsp;)<BR>
  <BR>
  # キーワード外の反応文<BR>
  com.unknown : \0\s[4]ごめん、よく分かんない。\e<BR>
  com.unknown : \0\s[8]なプー。\1\s[10]…。\e<BR>
  com.unknown : (<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;\0\s[0]…それから？\e<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;$(setstr System.Response.Reference0 $(Reference 0))<BR>
  &nbsp;&nbsp;)<BR>
  <BR>
  # コミュニケートイベントでcomエントリを登録<BR>
  reply.OnCommunicate : $(communicate com ${com.unknown})<BR>
</DIV>

<A name="randomtalk"></A>
<H3>9.3. 自発トーク</H3>

<P>
  自発的にトークをするには、
  <SPAN class="tt">OnSecondChange</SPAN>イベントを使うのが一般的です。
  ほぼ毎秒来るこのイベントが発生するたびに内部でカウンタを1ずつ増やし、
  カウンタが指定の値になったら、
  <SPAN class="tt">OnSecondChange</SPAN>でトークを返す、という方法です。
</P><P>
  このとき注意が必要なのは、
  <SPAN class="tt">OnSecondChange</SPAN>が最小化しているときも発生する、
  という点です。
  <SPAN class="tt">OnSecondChange</SPAN>でトークが捨てられるか否かは、
  Reference3の1/0で判定できます。
</P><P>
  以上を踏まえて、簡単な自発トークをするスクリプトを組んでみます。
  伝統的理由から、
  トークは<SPAN class="tt">sentence</SPAN>エントリにあるものとします。
</P>

<DIV class="sample">
  System.Callback.OnGET : ${reply.${System.Request.ID}}<BR>
  <BR>
  # トーク周期(秒)<BR>
  # このエントリに指定した時間間隔で発話する<BR>
  interval : 90<BR>
  <BR>
  # トークカウンタ<BR>
  # このカウンタがトーク周期と等しくなったら発話する<BR>
  talkcounter : 0<BR>
  <BR>
  # OnSecondChangeイベント<BR>
  # Reference3が1なら、トークを返しても大丈夫<BR>
  reply.OnSecondChange : $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if ${System.Request.Reference3} $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc talkcounter;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# カウンタがトーク周期以上になっていたら発話し、<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# カウンタをリセットする<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if $[ ${talkcounter} &gt;= ${interval} ] $(<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry sentence;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstr talkcounter 0;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;);<BR>
  &nbsp;&nbsp;)<BR>
</DIV>

</BODY>
</HTML>
